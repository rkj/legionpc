/******************************************************************
 * File: alan_parser.cc
 *
 * This file was automatically generated by CppCC Version 0.0.8
 * DO NOT EDIT MANUALLY
 ******************************************************************/



#include "alan_parser.hh"


#line 129 "ALan.cg"
AlanCode* cppcc::
#line 16 "alan_parser.cc"
AlanParser::parse ()
     throw (
#line 129 "ALan.cg"
AlanException,
#line 21 "alan_parser.cc"
ScanException, ParseException)
{
#line 131 "ALan.cg"
 code = new AlanCode(); ;
#line 26 "alan_parser.cc"

  lista_instrukcji();
  consumeToken(AlanToken::eof);
  {
#line 134 "ALan.cg"
 return code; }
#line 33 "alan_parser.cc"

}


void cppcc::AlanParser::lista_instrukcji ()
     throw (
#line 137 "ALan.cg"
AlanException,
#line 42 "alan_parser.cc"
ScanException, ParseException)
{
  while ((scanner.la()->id == AlanToken::BOOL) || (scanner.la()->id == AlanToken::INT) || (scanner.la()->id == AlanToken::FLOAT) || (scanner.la()->id == AlanToken::STRING) || (scanner.la()->id == AlanToken::MOVE) || (scanner.la()->id == AlanToken::ANIM) || (scanner.la()->id == AlanToken::SCALE) || (scanner.la()->id == AlanToken::GOTO) || (scanner.la()->id == AlanToken::GOSUB) || (scanner.la()->id == AlanToken::RETURN) || (scanner.la()->id == AlanToken::FOR) || (scanner.la()->id == AlanToken::NEXT) || (scanner.la()->id == AlanToken::WHILE) || (scanner.la()->id == AlanToken::WEND) || (scanner.la()->id == AlanToken::IF) || (scanner.la()->id == AlanToken::ELSE) || (scanner.la()->id == AlanToken::EIF) || (scanner.la()->id == AlanToken::PAUSE) || (scanner.la()->id == AlanToken::IDENT)) {
    if (__la_0_(2147483647)) {
      label();
    } else { 
      pojedyncza_instrukcja();
    }
  }
}


void cppcc::AlanParser::label ()
     throw (
#line 145 "ALan.cg"
AlanException,
#line 59 "alan_parser.cc"
ScanException, ParseException)
{
#line 147 "ALan.cg"
 string id = ""; ;
#line 64 "alan_parser.cc"

  consumeToken(AlanToken::IDENT);
  {
#line 148 "ALan.cg"
 id = token->image(); }
#line 70 "alan_parser.cc"

  consumeToken(AlanToken::SEMICOLON);
  {
#line 149 "ALan.cg"
 code->AddLabel(id); }
#line 76 "alan_parser.cc"

}


void cppcc::AlanParser::pojedyncza_instrukcja ()
     throw (
#line 152 "ALan.cg"
AlanException,
#line 85 "alan_parser.cc"
ScanException, ParseException)
{
  if ((scanner.la()->id == AlanToken::BOOL) || (scanner.la()->id == AlanToken::INT) || (scanner.la()->id == AlanToken::FLOAT) || (scanner.la()->id == AlanToken::STRING)) {
    declaration();
  } else { 
    if ((scanner.la()->id == AlanToken::MOVE)) {
      instr_move();
    } else { 
      if ((scanner.la()->id == AlanToken::ANIM)) {
        instr_anim();
      } else { 
        if ((scanner.la()->id == AlanToken::SCALE)) {
          instr_scale();
        } else { 
          if ((scanner.la()->id == AlanToken::GOTO)) {
            instr_goto();
          } else { 
            if ((scanner.la()->id == AlanToken::GOSUB)) {
              instr_gosub();
            } else { 
              if ((scanner.la()->id == AlanToken::RETURN)) {
                instr_return();
              } else { 
                if ((scanner.la()->id == AlanToken::IDENT)) {
                  instr_let();
                } else { 
                  if ((scanner.la()->id == AlanToken::FOR)) {
                    instr_for();
                  } else { 
                    if ((scanner.la()->id == AlanToken::NEXT)) {
                      instr_next();
                    } else { 
                      if ((scanner.la()->id == AlanToken::WHILE)) {
                        instr_while();
                      } else { 
                        if ((scanner.la()->id == AlanToken::WEND)) {
                          instr_wend();
                        } else { 
                          if ((scanner.la()->id == AlanToken::IF)) {
                            instr_if();
                          } else { 
                            if ((scanner.la()->id == AlanToken::ELSE)) {
                              instr_else();
                            } else { 
                              if ((scanner.la()->id == AlanToken::EIF)) {
                                instr_eif();
                              } else { 
                                instr_pause();
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}


void cppcc::AlanParser::declaration ()
     throw (
#line 172 "ALan.cg"
AlanException,
#line 156 "alan_parser.cc"
ScanException, ParseException)
{
#line 174 "ALan.cg"
 char type = TP_BAD; ;
#line 161 "alan_parser.cc"

  
#line 175 "ALan.cg"
type = 
#line 166 "alan_parser.cc"
typeID();
  declVarList(
#line 176 "ALan.cg"
type);
#line 171 "alan_parser.cc"

}



#line 179 "ALan.cg"
char cppcc::
#line 179 "alan_parser.cc"
AlanParser::typeID ()
     throw (
#line 179 "ALan.cg"
AlanException,
#line 184 "alan_parser.cc"
ScanException, ParseException)
{
  if ((scanner.la()->id == AlanToken::BOOL)) {
    consumeToken(AlanToken::BOOL);
    {
#line 181 "ALan.cg"
 return TP_BOOL; }
#line 192 "alan_parser.cc"

  } else { 
    if ((scanner.la()->id == AlanToken::INT)) {
      consumeToken(AlanToken::INT);
      {
#line 182 "ALan.cg"
 return TP_INT; }
#line 200 "alan_parser.cc"

    } else { 
      if ((scanner.la()->id == AlanToken::FLOAT)) {
        consumeToken(AlanToken::FLOAT);
        {
#line 183 "ALan.cg"
 return TP_FLOAT; }
#line 208 "alan_parser.cc"

      } else { 
        consumeToken(AlanToken::STRING);
        {
#line 184 "ALan.cg"
 return TP_STRING; }
#line 215 "alan_parser.cc"

      }
    }
  }
}


void cppcc::AlanParser::declVarList (
#line 187 "ALan.cg"
char type)
#line 226 "alan_parser.cc"

     throw (
#line 187 "ALan.cg"
AlanException,
#line 231 "alan_parser.cc"
ScanException, ParseException)
{
  declVar(
#line 189 "ALan.cg"
type);
#line 237 "alan_parser.cc"

  while ((scanner.la()->id == AlanToken::COMMA)) {
    consumeToken(AlanToken::COMMA);
    declVar(
#line 190 "ALan.cg"
type);
#line 244 "alan_parser.cc"

  }
}


void cppcc::AlanParser::declVar (
#line 194 "ALan.cg"
char type)
#line 253 "alan_parser.cc"

     throw (
#line 194 "ALan.cg"
AlanException,
#line 258 "alan_parser.cc"
ScanException, ParseException)
{
#line 196 "ALan.cg"
 AlanVariable *var = 0; ;
#line 263 "alan_parser.cc"

  consumeToken(AlanToken::IDENT);
  {
#line 197 "ALan.cg"
 var = code->AddVar(token->image(),type);
								if( 0 == var ) {
									throw AlanException( token->bPos.ln, token->bPos.col, "Zmienna " + token->image() + " jest już zadeklarowana" );
								}
							}
#line 273 "alan_parser.cc"

}



#line 204 "ALan.cg"
AlanVariable* cppcc::
#line 281 "alan_parser.cc"
AlanParser::Variable ()
     throw (
#line 204 "ALan.cg"
AlanException,
#line 286 "alan_parser.cc"
ScanException, ParseException)
{
#line 206 "ALan.cg"
 AlanVariable* var = 0; ;
#line 291 "alan_parser.cc"

  consumeToken(AlanToken::IDENT);
  {
#line 207 "ALan.cg"
 var = code->GetVar(token->image());
								if( 0 == var ) {
									throw AlanException( token->bPos.ln, token->bPos.col, "Zmienna " + token->image() + " nie jest zadeklarowana" );
								}
								return var;
							}
#line 302 "alan_parser.cc"

}


void cppcc::AlanParser::instr_move ()
     throw (
#line 215 "ALan.cg"
AlanException,
#line 311 "alan_parser.cc"
ScanException, ParseException)
{
#line 217 "ALan.cg"
 vector<AlanExpr*> dx,dy,dr,dt;
			AlanExpr *e, *e3, *e4, *cnt;
		;
#line 318 "alan_parser.cc"

  consumeToken(AlanToken::MOVE);
  
#line 221 "ALan.cg"
cnt = 
#line 324 "alan_parser.cc"
Expr();
  {
#line 221 "ALan.cg"
 if( TP_INT != cnt->type ) throw AlanException( token->bPos.ln, token->bPos.col, "Wyrażenie określające krotność musi być typu INT" );
												cnt = Cast(TP_INT,cnt);
												if( 0 == cnt ) throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu INT" );
											}
#line 332 "alan_parser.cc"

  consumeToken(AlanToken::COMMA);
  consumeToken(AlanToken::LPAR);
  
#line 227 "ALan.cg"
e = 
#line 339 "alan_parser.cc"
Expr();
  {
#line 227 "ALan.cg"
 if( TP_FLOAT != e->type ) {
													if( ! TypesMatch(TP_FLOAT,e->type) ) throw AlanException( token->bPos.ln, token->bPos.col, "Próba przypisania krokowi w kierunku poziomym wartości innego typu niż " + TypeName(TP_FLOAT) );
													e = Cast(TP_FLOAT,e);
													if( 0 == e ) throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu FLOAT" );
												}
												dx.push_back(e);
											}
#line 350 "alan_parser.cc"

  consumeToken(AlanToken::COMMA);
  
#line 235 "ALan.cg"
e = 
#line 356 "alan_parser.cc"
Expr();
  {
#line 235 "ALan.cg"
 if( TP_FLOAT != e->type ) {
													if( ! TypesMatch(TP_FLOAT,e->type) ) throw AlanException( token->bPos.ln, token->bPos.col, "Próba przypisania krokowi w kierunku pionowym wartości innego typu niż " + TypeName(TP_FLOAT) );
													e = Cast(TP_FLOAT,e);
													if( 0 == e ) throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu FLOAT" );
												}
												dy.push_back(e);
											}
#line 367 "alan_parser.cc"

  consumeToken(AlanToken::COMMA);
  
#line 243 "ALan.cg"
e = 
#line 373 "alan_parser.cc"
Expr();
  {
#line 243 "ALan.cg"
	if( TP_FLOAT != e->type ) {
													if( ! TypesMatch(TP_FLOAT,e->type) ) throw AlanException( token->bPos.ln, token->bPos.col, "Próba przypisania parametrowi określającemu czas trwania klatki wartości innego typu niż " + TypeName(TP_FLOAT) );
													e = Cast(TP_FLOAT,e);
													if( 0 == e ) throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu FLOAT" );
												}
												e3 = e;
												e4 = 0;
											}
#line 385 "alan_parser.cc"

  if ((scanner.la()->id == AlanToken::COMMA)) {
    consumeToken(AlanToken::COMMA);
    
#line 253 "ALan.cg"
e = 
#line 392 "alan_parser.cc"
Expr();
    {
#line 253 "ALan.cg"
	if( TP_FLOAT != e->type ) {
													if( ! TypesMatch(TP_FLOAT,e->type) ) throw AlanException( token->bPos.ln, token->bPos.col, "Próba przypisania parametrowi określającemu czas trwania klatki wartości innego typu niż " + TypeName(TP_FLOAT) );
													e = Cast(TP_FLOAT,e);
													if( 0 == e ) throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu FLOAT" );
												}
												e4 = e;
											}
#line 403 "alan_parser.cc"

  } else { 
     /* lambda */
  }
  consumeToken(AlanToken::RPAR);
  {
#line 262 "ALan.cg"
	if( 0 != e4 ) {
													dr.push_back( e3 );
													dt.push_back( e4 );
												} else {
													dr.push_back( new AlanConstant(0.0f) );
													dt.push_back( e3 );
												}
											}
#line 419 "alan_parser.cc"

  while ((scanner.la()->id == AlanToken::LPAR)) {
    consumeToken(AlanToken::LPAR);
    
#line 227 "ALan.cg"
e = 
#line 426 "alan_parser.cc"
Expr();
    {
#line 227 "ALan.cg"
 if( TP_FLOAT != e->type ) {
													if( ! TypesMatch(TP_FLOAT,e->type) ) throw AlanException( token->bPos.ln, token->bPos.col, "Próba przypisania krokowi w kierunku poziomym wartości innego typu niż " + TypeName(TP_FLOAT) );
													e = Cast(TP_FLOAT,e);
													if( 0 == e ) throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu FLOAT" );
												}
												dx.push_back(e);
											}
#line 437 "alan_parser.cc"

    consumeToken(AlanToken::COMMA);
    
#line 235 "ALan.cg"
e = 
#line 443 "alan_parser.cc"
Expr();
    {
#line 235 "ALan.cg"
 if( TP_FLOAT != e->type ) {
													if( ! TypesMatch(TP_FLOAT,e->type) ) throw AlanException( token->bPos.ln, token->bPos.col, "Próba przypisania krokowi w kierunku pionowym wartości innego typu niż " + TypeName(TP_FLOAT) );
													e = Cast(TP_FLOAT,e);
													if( 0 == e ) throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu FLOAT" );
												}
												dy.push_back(e);
											}
#line 454 "alan_parser.cc"

    consumeToken(AlanToken::COMMA);
    
#line 243 "ALan.cg"
e = 
#line 460 "alan_parser.cc"
Expr();
    {
#line 243 "ALan.cg"
	if( TP_FLOAT != e->type ) {
													if( ! TypesMatch(TP_FLOAT,e->type) ) throw AlanException( token->bPos.ln, token->bPos.col, "Próba przypisania parametrowi określającemu czas trwania klatki wartości innego typu niż " + TypeName(TP_FLOAT) );
													e = Cast(TP_FLOAT,e);
													if( 0 == e ) throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu FLOAT" );
												}
												e3 = e;
												e4 = 0;
											}
#line 472 "alan_parser.cc"

    if ((scanner.la()->id == AlanToken::COMMA)) {
      consumeToken(AlanToken::COMMA);
      
#line 253 "ALan.cg"
e = 
#line 479 "alan_parser.cc"
Expr();
      {
#line 253 "ALan.cg"
	if( TP_FLOAT != e->type ) {
													if( ! TypesMatch(TP_FLOAT,e->type) ) throw AlanException( token->bPos.ln, token->bPos.col, "Próba przypisania parametrowi określającemu czas trwania klatki wartości innego typu niż " + TypeName(TP_FLOAT) );
													e = Cast(TP_FLOAT,e);
													if( 0 == e ) throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu FLOAT" );
												}
												e4 = e;
											}
#line 490 "alan_parser.cc"

    } else { 
       /* lambda */
    }
    consumeToken(AlanToken::RPAR);
    {
#line 262 "ALan.cg"
	if( 0 != e4 ) {
													dr.push_back( e3 );
													dt.push_back( e4 );
												} else {
													dr.push_back( new AlanConstant(0.0f) );
													dt.push_back( e3 );
												}
											}
#line 506 "alan_parser.cc"

  }
  {
#line 271 "ALan.cg"
 code->AddInstrMove(cnt,dx,dy,dr,dt); }
#line 512 "alan_parser.cc"

}


void cppcc::AlanParser::instr_anim ()
     throw (
#line 275 "ALan.cg"
AlanException,
#line 521 "alan_parser.cc"
ScanException, ParseException)
{
#line 277 "ALan.cg"
 AlanExpr *e, *cnt;
			vector<AlanExpr*> img, dt;
		;
#line 528 "alan_parser.cc"

  consumeToken(AlanToken::ANIM);
  
#line 281 "ALan.cg"
cnt = 
#line 534 "alan_parser.cc"
Expr();
  {
#line 281 "ALan.cg"
 if( TP_INT != cnt->type ) throw AlanException( token->bPos.ln, token->bPos.col, "Wyrażenie określające krotność musi być typu INT" );
												cnt = Cast(TP_INT,cnt);
												if( 0 == cnt ) throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu INT" );
											}
#line 542 "alan_parser.cc"

  consumeToken(AlanToken::COMMA);
  consumeToken(AlanToken::LPAR);
  
#line 287 "ALan.cg"
e = 
#line 549 "alan_parser.cc"
Expr();
  {
#line 287 "ALan.cg"
 if( TP_STRING != e->type ) {
													if( ! TypesMatch(TP_STRING,e->type) ) throw AlanException( token->bPos.ln, token->bPos.col, "Próba przypisania ID tekstury wartości innego typu niż " + TypeName(TP_STRING) );
													e = Cast(TP_STRING,e);
													if( 0 == e ) throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu STRING" );
												}
												img.push_back(e);
											}
#line 560 "alan_parser.cc"

  consumeToken(AlanToken::COMMA);
  
#line 295 "ALan.cg"
e = 
#line 566 "alan_parser.cc"
Expr();
  {
#line 295 "ALan.cg"
	if( TP_FLOAT != e->type ) {
													if( ! TypesMatch(TP_FLOAT,e->type) ) throw AlanException( token->bPos.ln, token->bPos.col, "Próba przypisania parametrowi określającemu czas trwania klatki wartości innego typu niż " + TypeName(TP_FLOAT) );
													e = Cast(TP_FLOAT,e);
													if( 0 == e ) throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu FLOAT" );
												}
												dt.push_back(e);
											}
#line 577 "alan_parser.cc"

  consumeToken(AlanToken::RPAR);
  while ((scanner.la()->id == AlanToken::LPAR)) {
    consumeToken(AlanToken::LPAR);
    
#line 287 "ALan.cg"
e = 
#line 585 "alan_parser.cc"
Expr();
    {
#line 287 "ALan.cg"
 if( TP_STRING != e->type ) {
													if( ! TypesMatch(TP_STRING,e->type) ) throw AlanException( token->bPos.ln, token->bPos.col, "Próba przypisania ID tekstury wartości innego typu niż " + TypeName(TP_STRING) );
													e = Cast(TP_STRING,e);
													if( 0 == e ) throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu STRING" );
												}
												img.push_back(e);
											}
#line 596 "alan_parser.cc"

    consumeToken(AlanToken::COMMA);
    
#line 295 "ALan.cg"
e = 
#line 602 "alan_parser.cc"
Expr();
    {
#line 295 "ALan.cg"
	if( TP_FLOAT != e->type ) {
													if( ! TypesMatch(TP_FLOAT,e->type) ) throw AlanException( token->bPos.ln, token->bPos.col, "Próba przypisania parametrowi określającemu czas trwania klatki wartości innego typu niż " + TypeName(TP_FLOAT) );
													e = Cast(TP_FLOAT,e);
													if( 0 == e ) throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu FLOAT" );
												}
												dt.push_back(e);
											}
#line 613 "alan_parser.cc"

    consumeToken(AlanToken::RPAR);
  }
  {
#line 304 "ALan.cg"
 code->AddInstrAnim(cnt,img,dt); }
#line 620 "alan_parser.cc"

}


void cppcc::AlanParser::instr_scale ()
     throw (
#line 307 "ALan.cg"
AlanException,
#line 629 "alan_parser.cc"
ScanException, ParseException)
{
#line 309 "ALan.cg"
 vector<AlanExpr*> sx,sy,dt;
			AlanExpr *e, *cnt;
		;
#line 636 "alan_parser.cc"

  consumeToken(AlanToken::SCALE);
  
#line 313 "ALan.cg"
cnt = 
#line 642 "alan_parser.cc"
Expr();
  {
#line 313 "ALan.cg"
 if( TP_INT != cnt->type ) throw AlanException( token->bPos.ln, token->bPos.col, "Wyrażenie określające krotność musi być typu INT" );
												cnt = Cast(TP_INT,cnt);
												if( 0 == cnt ) throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu INT" );
											}
#line 650 "alan_parser.cc"

  consumeToken(AlanToken::COMMA);
  consumeToken(AlanToken::LPAR);
  
#line 319 "ALan.cg"
e = 
#line 657 "alan_parser.cc"
Expr();
  {
#line 319 "ALan.cg"
 if( TP_FLOAT != e->type ) {
													if( ! TypesMatch(TP_FLOAT,e->type) ) throw AlanException( token->bPos.ln, token->bPos.col, "Próba przypisania współczynnikowi rozmiaru poziomego wartości innego typu niż " + TypeName(TP_FLOAT) );
													e = Cast(TP_FLOAT,e);
													if( 0 == e ) throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu FLOAT" );
												}
												sx.push_back(e);
											}
#line 668 "alan_parser.cc"

  consumeToken(AlanToken::COMMA);
  
#line 327 "ALan.cg"
e = 
#line 674 "alan_parser.cc"
Expr();
  {
#line 327 "ALan.cg"
 if( TP_FLOAT != e->type ) {
													if( ! TypesMatch(TP_FLOAT,e->type) ) throw AlanException( token->bPos.ln, token->bPos.col, "Próba przypisania współczynnikowi rozmiaru pionowego wartości innego typu niż " + TypeName(TP_FLOAT) );
													e = Cast(TP_FLOAT,e);
													if( 0 == e ) throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu FLOAT" );
												}
												sy.push_back(e);
											}
#line 685 "alan_parser.cc"

  consumeToken(AlanToken::COMMA);
  
#line 335 "ALan.cg"
e = 
#line 691 "alan_parser.cc"
Expr();
  {
#line 335 "ALan.cg"
	if( TP_FLOAT != e->type ) {
													if( ! TypesMatch(TP_FLOAT,e->type) ) throw AlanException( token->bPos.ln, token->bPos.col, "Próba przypisania parametrowi określającemu czas trwania zmiany rozmiaru wartości innego typu niż " + TypeName(TP_FLOAT) );
													e = Cast(TP_FLOAT,e);
													if( 0 == e ) throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu FLOAT" );
												}
												dt.push_back(e);
											}
#line 702 "alan_parser.cc"

  consumeToken(AlanToken::RPAR);
  while ((scanner.la()->id == AlanToken::LPAR)) {
    consumeToken(AlanToken::LPAR);
    
#line 319 "ALan.cg"
e = 
#line 710 "alan_parser.cc"
Expr();
    {
#line 319 "ALan.cg"
 if( TP_FLOAT != e->type ) {
													if( ! TypesMatch(TP_FLOAT,e->type) ) throw AlanException( token->bPos.ln, token->bPos.col, "Próba przypisania współczynnikowi rozmiaru poziomego wartości innego typu niż " + TypeName(TP_FLOAT) );
													e = Cast(TP_FLOAT,e);
													if( 0 == e ) throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu FLOAT" );
												}
												sx.push_back(e);
											}
#line 721 "alan_parser.cc"

    consumeToken(AlanToken::COMMA);
    
#line 327 "ALan.cg"
e = 
#line 727 "alan_parser.cc"
Expr();
    {
#line 327 "ALan.cg"
 if( TP_FLOAT != e->type ) {
													if( ! TypesMatch(TP_FLOAT,e->type) ) throw AlanException( token->bPos.ln, token->bPos.col, "Próba przypisania współczynnikowi rozmiaru pionowego wartości innego typu niż " + TypeName(TP_FLOAT) );
													e = Cast(TP_FLOAT,e);
													if( 0 == e ) throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu FLOAT" );
												}
												sy.push_back(e);
											}
#line 738 "alan_parser.cc"

    consumeToken(AlanToken::COMMA);
    
#line 335 "ALan.cg"
e = 
#line 744 "alan_parser.cc"
Expr();
    {
#line 335 "ALan.cg"
	if( TP_FLOAT != e->type ) {
													if( ! TypesMatch(TP_FLOAT,e->type) ) throw AlanException( token->bPos.ln, token->bPos.col, "Próba przypisania parametrowi określającemu czas trwania zmiany rozmiaru wartości innego typu niż " + TypeName(TP_FLOAT) );
													e = Cast(TP_FLOAT,e);
													if( 0 == e ) throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu FLOAT" );
												}
												dt.push_back(e);
											}
#line 755 "alan_parser.cc"

    consumeToken(AlanToken::RPAR);
  }
  {
#line 344 "ALan.cg"
 code->AddInstrScale(cnt,sx,sy,dt); }
#line 762 "alan_parser.cc"

}


void cppcc::AlanParser::instr_goto ()
     throw (
#line 347 "ALan.cg"
AlanException,
#line 771 "alan_parser.cc"
ScanException, ParseException)
{
#line 349 "ALan.cg"
 string label = ""; ;
#line 776 "alan_parser.cc"

  consumeToken(AlanToken::GOTO);
  consumeToken(AlanToken::IDENT);
  {
#line 351 "ALan.cg"
 label = token->image();
								code->AddInstrGoto(label);
							}
#line 785 "alan_parser.cc"

}


void cppcc::AlanParser::instr_gosub ()
     throw (
#line 356 "ALan.cg"
AlanException,
#line 794 "alan_parser.cc"
ScanException, ParseException)
{
#line 358 "ALan.cg"
 string label = ""; ;
#line 799 "alan_parser.cc"

  consumeToken(AlanToken::GOSUB);
  consumeToken(AlanToken::IDENT);
  {
#line 360 "ALan.cg"
 label = token->image();
								code->AddInstrGosub(label);
							}
#line 808 "alan_parser.cc"

}


void cppcc::AlanParser::instr_return ()
     throw (
#line 365 "ALan.cg"
AlanException,
#line 817 "alan_parser.cc"
ScanException, ParseException)
{
  consumeToken(AlanToken::RETURN);
  {
#line 367 "ALan.cg"
 code->AddInstrReturn();	}
#line 824 "alan_parser.cc"

}


void cppcc::AlanParser::instr_let ()
     throw (
#line 370 "ALan.cg"
AlanException,
#line 833 "alan_parser.cc"
ScanException, ParseException)
{
#line 372 "ALan.cg"
 AlanVariable *var=0; AlanExpr *e=0; ;
#line 838 "alan_parser.cc"

  
#line 373 "ALan.cg"
var = 
#line 843 "alan_parser.cc"
Variable();
  consumeToken(AlanToken::ASSIGN);
  
#line 375 "ALan.cg"
e = 
#line 849 "alan_parser.cc"
Expr();
  {
#line 375 "ALan.cg"
 if( var->type != e->type ) {
												if( ! TypesMatch(var->type,e->type) ) throw AlanException( token->bPos.ln, token->bPos.col, "Próba przypisania zmiennej " + var->GetID() + " wartości innego typu niż " + TypeName(var->type) );
												//rzutujemy na pierwszy typ
												e = Cast(var->type,e);
												if( 0 == e ) throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu " + TypeName(var->type) );
											}
											code->AddInstrLet(var,e);
										}
#line 861 "alan_parser.cc"

}


void cppcc::AlanParser::instr_for ()
     throw (
#line 386 "ALan.cg"
AlanException,
#line 870 "alan_parser.cc"
ScanException, ParseException)
{
#line 388 "ALan.cg"
 AlanVariable *var=0; AlanExpr *beg=0, *end=0, *step=0;
			string error;
		;
#line 877 "alan_parser.cc"

  consumeToken(AlanToken::FOR);
  
#line 392 "ALan.cg"
var = 
#line 883 "alan_parser.cc"
Variable();
  consumeToken(AlanToken::ASSIGN);
  
#line 394 "ALan.cg"
beg = 
#line 889 "alan_parser.cc"
Expr();
  consumeToken(AlanToken::TO);
  
#line 396 "ALan.cg"
end = 
#line 895 "alan_parser.cc"
Expr();
  if ((scanner.la()->id == AlanToken::STEP)) {
    consumeToken(AlanToken::STEP);
    
#line 398 "ALan.cg"
step = 
#line 902 "alan_parser.cc"
Expr();
  } else { 
     /* lambda */
  }
  {
#line 400 "ALan.cg"
 if( ! IsNumType(var->type) ) throw AlanException( token->bPos.ln, token->bPos.col, "Zmienna licznikowa instrukcji FOR musi być typu numerycznego a nie typu " + TypeName(var->type) );
								//TODO - dodac rzutowanie beg,end,step do typu var
								if( ! code->AddInstrFor(var,beg,end,step,error) ) throw AlanException( token->bPos.ln, token->bPos.col, error );
							}
#line 913 "alan_parser.cc"

}


void cppcc::AlanParser::instr_next ()
     throw (
#line 406 "ALan.cg"
AlanException,
#line 922 "alan_parser.cc"
ScanException, ParseException)
{
#line 407 "ALan.cg"
 string error; ;
#line 927 "alan_parser.cc"

  consumeToken(AlanToken::NEXT);
  {
#line 408 "ALan.cg"
 if( ! code->AddInstrNext(error) ) throw AlanException( token->bPos.ln, token->bPos.col, error );
							}
#line 934 "alan_parser.cc"

}


void cppcc::AlanParser::instr_while ()
     throw (
#line 412 "ALan.cg"
AlanException,
#line 943 "alan_parser.cc"
ScanException, ParseException)
{
#line 414 "ALan.cg"
 AlanExpr *exp=0;
			string error;
		;
#line 950 "alan_parser.cc"

  consumeToken(AlanToken::WHILE);
  
#line 418 "ALan.cg"
exp = 
#line 956 "alan_parser.cc"
Expr();
  {
#line 418 "ALan.cg"
	if( exp->type != TP_BOOL) throw AlanException( token->bPos.ln, token->bPos.col, "Warunek instrukcji WHILE musi być typu BOOL a nie typu " + TypeName(exp->type) );
													if( ! code->AddInstrWhile(exp,error) ) throw AlanException( token->bPos.ln, token->bPos.col, error );
												}
#line 963 "alan_parser.cc"

}


void cppcc::AlanParser::instr_wend ()
     throw (
#line 423 "ALan.cg"
AlanException,
#line 972 "alan_parser.cc"
ScanException, ParseException)
{
#line 424 "ALan.cg"
 string error; ;
#line 977 "alan_parser.cc"

  consumeToken(AlanToken::WEND);
  {
#line 425 "ALan.cg"
 if( ! code->AddInstrWend(error) ) throw AlanException( token->bPos.ln, token->bPos.col, error );
							}
#line 984 "alan_parser.cc"

}


void cppcc::AlanParser::instr_if ()
     throw (
#line 429 "ALan.cg"
AlanException,
#line 993 "alan_parser.cc"
ScanException, ParseException)
{
#line 431 "ALan.cg"
 AlanExpr *exp; string error; ;
#line 998 "alan_parser.cc"

  consumeToken(AlanToken::IF);
  
#line 433 "ALan.cg"
exp = 
#line 1004 "alan_parser.cc"
Expr();
  {
#line 433 "ALan.cg"
	if( exp->type != TP_BOOL) throw AlanException( token->bPos.ln, token->bPos.col, "Warunek instrukcji IF musi być typu BOOL a nie typu " + TypeName(exp->type) );
													if( ! code->AddInstrIf(exp,error) ) throw AlanException( token->bPos.ln, token->bPos.col, error );
												}
#line 1011 "alan_parser.cc"

}


void cppcc::AlanParser::instr_else ()
     throw (
#line 438 "ALan.cg"
AlanException,
#line 1020 "alan_parser.cc"
ScanException, ParseException)
{
#line 439 "ALan.cg"
 string error; ;
#line 1025 "alan_parser.cc"

  consumeToken(AlanToken::ELSE);
  {
#line 440 "ALan.cg"
 if( ! code->AddInstrElse(error) ) throw AlanException( token->bPos.ln, token->bPos.col, error );
											}
#line 1032 "alan_parser.cc"

}


void cppcc::AlanParser::instr_eif ()
     throw (
#line 444 "ALan.cg"
AlanException,
#line 1041 "alan_parser.cc"
ScanException, ParseException)
{
#line 445 "ALan.cg"
 string error; ;
#line 1046 "alan_parser.cc"

  consumeToken(AlanToken::EIF);
  {
#line 446 "ALan.cg"
 if( ! code->AddInstrEif(error) ) throw AlanException( token->bPos.ln, token->bPos.col, error );
											}
#line 1053 "alan_parser.cc"

}


void cppcc::AlanParser::instr_pause ()
     throw (
#line 450 "ALan.cg"
AlanException,
#line 1062 "alan_parser.cc"
ScanException, ParseException)
{
#line 451 "ALan.cg"
 AlanExpr *exp=0; string error; ;
#line 1067 "alan_parser.cc"

  consumeToken(AlanToken::PAUSE);
  if (__la_1_(2147483647)) {
    
#line 454 "ALan.cg"
exp = 
#line 1074 "alan_parser.cc"
Expr();
    {
#line 454 "ALan.cg"
	if( exp->type != TP_BOOL) throw AlanException( token->bPos.ln, token->bPos.col, "Warunek instrukcji PAUSE WHILE musi być typu BOOL a nie typu " + TypeName(exp->type) );
											}
#line 1080 "alan_parser.cc"

  } else { 
     /* lambda */
  }
  {
#line 457 "ALan.cg"
	if( 0 == exp ) {
				if( ! code->AddInstrPause(error) ) throw AlanException( token->bPos.ln, token->bPos.col, error );
			} else {
				if( ! code->AddInstrPauseWhile(exp,error) ) throw AlanException( token->bPos.ln, token->bPos.col, error );
			}
		}
#line 1093 "alan_parser.cc"

}



#line 465 "ALan.cg"
AlanExpr* cppcc::
#line 1101 "alan_parser.cc"
AlanParser::buildinFunc ()
     throw (
#line 465 "ALan.cg"
AlanException,
#line 1106 "alan_parser.cc"
ScanException, ParseException)
{
#line 467 "ALan.cg"
 AlanVariable *var=0; AlanExpr *str = 0, *beg = 0, *cnt = 0, *pat = 0, *key = 0, *p1 = 0, *p2 = 0; ;
#line 1111 "alan_parser.cc"

  if ((scanner.la()->id == AlanToken::IS)) {
    consumeToken(AlanToken::IS);
    if ((scanner.la()->id == AlanToken::MOVING)) {
      consumeToken(AlanToken::MOVING);
      {
#line 471 "ALan.cg"
 return new AlanFuncIsMoving(); }
#line 1120 "alan_parser.cc"

    } else { 
      if ((scanner.la()->id == AlanToken::ANIMATING)) {
        consumeToken(AlanToken::ANIMATING);
        {
#line 472 "ALan.cg"
 return new AlanFuncIsAnimating(); }
#line 1128 "alan_parser.cc"

      } else { 
        consumeToken(AlanToken::SCALING);
        {
#line 473 "ALan.cg"
 return new AlanFuncIsScaling(); }
#line 1135 "alan_parser.cc"

      }
    }
  } else { 
    if ((scanner.la()->id == AlanToken::MOUSE)) {
      consumeToken(AlanToken::MOUSE);
      if ((scanner.la()->id == AlanToken::IDENT)) {
        
#line 478 "ALan.cg"
var = 
#line 1146 "alan_parser.cc"
Variable();
        {
#line 478 "ALan.cg"
 if( "X" == var->GetID() )
																		return new AlanFuncMouseX();
																	else if( "Y" == var->GetID() )
																		return new AlanFuncMouseY();
																	else
																		throw AlanException( token->bPos.ln, token->bPos.col, "Po MOUSE może występować tylko X lub Y" );
																}
#line 1157 "alan_parser.cc"

      } else { 
        consumeToken(AlanToken::KEY);
        consumeToken(AlanToken::LPAR);
        
#line 487 "ALan.cg"
key = 
#line 1165 "alan_parser.cc"
Expr();
        {
#line 487 "ALan.cg"
	if( ! TypesMatch( TP_INT, key->type ) ) throw AlanException( token->bPos.ln, token->bPos.col, "Parametr 'k' funkcji MOUSE KEY musi być typu INT a nie typu " + TypeName(key->type) );
																	Cast(TP_INT,key);
																	if( 0 == key )  throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu INT" );
																}
#line 1173 "alan_parser.cc"

        consumeToken(AlanToken::RPAR);
        {
#line 491 "ALan.cg"
 return new AlanFuncMouseKey(key); }
#line 1179 "alan_parser.cc"

      }
    } else { 
      if ((scanner.la()->id == AlanToken::STRLEN)) {
        consumeToken(AlanToken::STRLEN);
        consumeToken(AlanToken::LPAR);
        
#line 496 "ALan.cg"
str = 
#line 1189 "alan_parser.cc"
Expr();
        {
#line 496 "ALan.cg"
	if( ! TypesMatch( TP_STRING, str->type ) ) throw AlanException( token->bPos.ln, token->bPos.col, "Parametr 'str' funkcji STRLEN musi być typu STRING a nie typu " + TypeName(str->type) );
																	Cast(TP_STRING,str);
																	if( 0 == str )  throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu STRING" );
																}
#line 1197 "alan_parser.cc"

        consumeToken(AlanToken::RPAR);
        {
#line 500 "ALan.cg"
 return new AlanFuncStrLen(str); }
#line 1203 "alan_parser.cc"

      } else { 
        if ((scanner.la()->id == AlanToken::SUBSTR)) {
          consumeToken(AlanToken::SUBSTR);
          consumeToken(AlanToken::LPAR);
          
#line 504 "ALan.cg"
str = 
#line 1212 "alan_parser.cc"
Expr();
          {
#line 504 "ALan.cg"
	if( ! TypesMatch( TP_STRING, str->type ) ) throw AlanException( token->bPos.ln, token->bPos.col, "Parametr 'str' funkcji STRLEN musi być typu STRING a nie typu " + TypeName(str->type) );
																	Cast(TP_STRING,str);
																	if( 0 == str )  throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu STRING" );
																}
#line 1220 "alan_parser.cc"

          consumeToken(AlanToken::COMMA);
          
#line 509 "ALan.cg"
beg = 
#line 1226 "alan_parser.cc"
Expr();
          {
#line 509 "ALan.cg"
	if( ! TypesMatch( TP_INT, beg->type ) ) throw AlanException( token->bPos.ln, token->bPos.col, "Parametr 'beg' funkcji STRLEN musi być typu INT a nie typu " + TypeName(beg->type) );
																	Cast(TP_INT,beg);
																	if( 0 == beg )  throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu INT" );
																}
#line 1234 "alan_parser.cc"

          consumeToken(AlanToken::COMMA);
          
#line 514 "ALan.cg"
cnt = 
#line 1240 "alan_parser.cc"
Expr();
          {
#line 514 "ALan.cg"
	if( ! TypesMatch( TP_INT, cnt->type ) ) throw AlanException( token->bPos.ln, token->bPos.col, "Parametr 'cnt' funkcji STRLEN musi być typu INT a nie typu " + TypeName(cnt->type) );
																	Cast(TP_INT,cnt);
																	if( 0 == cnt )  throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu INT" );
																}
#line 1248 "alan_parser.cc"

          consumeToken(AlanToken::RPAR);
          {
#line 518 "ALan.cg"
 return new AlanFuncSubStr(str,beg,cnt); }
#line 1254 "alan_parser.cc"

        } else { 
          if ((scanner.la()->id == AlanToken::INSTR)) {
            consumeToken(AlanToken::INSTR);
            consumeToken(AlanToken::LPAR);
            
#line 522 "ALan.cg"
str = 
#line 1263 "alan_parser.cc"
Expr();
            {
#line 522 "ALan.cg"
	if( ! TypesMatch( TP_STRING, str->type ) ) throw AlanException( token->bPos.ln, token->bPos.col, "Parametr 'str' funkcji INSTR musi być typu STRING a nie typu " + TypeName(str->type) );
																	Cast(TP_STRING,str);
																	if( 0 == str )  throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu STRING" );
																}
#line 1271 "alan_parser.cc"

            consumeToken(AlanToken::COMMA);
            
#line 527 "ALan.cg"
pat = 
#line 1277 "alan_parser.cc"
Expr();
            {
#line 527 "ALan.cg"
	if( ! TypesMatch( TP_STRING, pat->type ) ) throw AlanException( token->bPos.ln, token->bPos.col, "Parametr 'pat' funkcji INSTR musi być typu STRING a nie typu " + TypeName(beg->type) );
																	Cast(TP_STRING,pat);
																	if( 0 == pat )  throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu STRING" );
																}
#line 1285 "alan_parser.cc"

            consumeToken(AlanToken::COMMA);
            
#line 532 "ALan.cg"
beg = 
#line 1291 "alan_parser.cc"
Expr();
            {
#line 532 "ALan.cg"
	if( ! TypesMatch( TP_INT, beg->type ) ) throw AlanException( token->bPos.ln, token->bPos.col, "Parametr 'beg' funkcji INSTR musi być typu INT a nie typu " + TypeName(beg->type) );
																	Cast(TP_INT,beg);
																	if( 0 == beg )  throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu INT" );
																}
#line 1299 "alan_parser.cc"

            consumeToken(AlanToken::RPAR);
            {
#line 536 "ALan.cg"
 return new AlanFuncInStr(str,pat,beg); }
#line 1305 "alan_parser.cc"

          } else { 
            if ((scanner.la()->id == AlanToken::RAND)) {
              consumeToken(AlanToken::RAND);
              consumeToken(AlanToken::LPAR);
              
#line 540 "ALan.cg"
p1 = 
#line 1314 "alan_parser.cc"
Expr();
              {
#line 540 "ALan.cg"
	if( ! TypesMatch( TP_INT, p1->type ) ) throw AlanException( token->bPos.ln, token->bPos.col, "Parametr nr 1 funkcji RAND musi być typu INT a nie typu " + TypeName(p1->type) );
																	Cast(TP_INT,p1);
																	if( 0 == p1 )  throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu INT" );
																}
#line 1322 "alan_parser.cc"

              consumeToken(AlanToken::COMMA);
              
#line 545 "ALan.cg"
p2 = 
#line 1328 "alan_parser.cc"
Expr();
              {
#line 545 "ALan.cg"
	if( ! TypesMatch( TP_INT, p2->type ) ) throw AlanException( token->bPos.ln, token->bPos.col, "Parametr nr 2 funkcji RAND musi być typu INT a nie typu " + TypeName(p2->type) );
																	Cast(TP_INT,p2);
																	if( 0 == p2 )  throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu INT" );
																}
#line 1336 "alan_parser.cc"

              consumeToken(AlanToken::RPAR);
              {
#line 549 "ALan.cg"
 return new AlanFuncRandI(p1,p2); }
#line 1342 "alan_parser.cc"

            } else { 
              if ((scanner.la()->id == AlanToken::RANDF)) {
                consumeToken(AlanToken::RANDF);
                consumeToken(AlanToken::LPAR);
                
#line 553 "ALan.cg"
p1 = 
#line 1351 "alan_parser.cc"
Expr();
                {
#line 553 "ALan.cg"
	if( ! TypesMatch( TP_FLOAT, p1->type ) ) throw AlanException( token->bPos.ln, token->bPos.col, "Parametr nr 1 funkcji RANDF musi być typu FLOAT a nie typu " + TypeName(p1->type) );
																	Cast(TP_FLOAT,p1);
																	if( 0 == p1 )  throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu FLOAT" );
																}
#line 1359 "alan_parser.cc"

                consumeToken(AlanToken::COMMA);
                
#line 558 "ALan.cg"
p2 = 
#line 1365 "alan_parser.cc"
Expr();
                {
#line 558 "ALan.cg"
	if( ! TypesMatch( TP_FLOAT, p2->type ) ) throw AlanException( token->bPos.ln, token->bPos.col, "Parametr nr 2 funkcji RANDF musi być typu FLOAT a nie typu " + TypeName(p2->type) );
																	Cast(TP_FLOAT,p2);
																	if( 0 == p2 )  throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu FLOAT" );
																}
#line 1373 "alan_parser.cc"

                consumeToken(AlanToken::RPAR);
                {
#line 562 "ALan.cg"
 return new AlanFuncRandF(p1,p2); }
#line 1379 "alan_parser.cc"

              } else { 
                if ((scanner.la()->id == AlanToken::SIN)) {
                  consumeToken(AlanToken::SIN);
                  consumeToken(AlanToken::LPAR);
                  
#line 566 "ALan.cg"
p1 = 
#line 1388 "alan_parser.cc"
Expr();
                  {
#line 566 "ALan.cg"
	if( ! TypesMatch( TP_FLOAT, p1->type ) ) throw AlanException( token->bPos.ln, token->bPos.col, "Parametr funkcji SIN musi być typu FLOAT a nie typu " + TypeName(p1->type) );
																	Cast(TP_FLOAT,p1);
																	if( 0 == p1 )  throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu FLOAT" );
																}
#line 1396 "alan_parser.cc"

                  consumeToken(AlanToken::RPAR);
                  {
#line 570 "ALan.cg"
 return new AlanFuncSin(p1); }
#line 1402 "alan_parser.cc"

                } else { 
                  if ((scanner.la()->id == AlanToken::COS)) {
                    consumeToken(AlanToken::COS);
                    consumeToken(AlanToken::LPAR);
                    
#line 574 "ALan.cg"
p1 = 
#line 1411 "alan_parser.cc"
Expr();
                    {
#line 574 "ALan.cg"
	if( ! TypesMatch( TP_FLOAT, p1->type ) ) throw AlanException( token->bPos.ln, token->bPos.col, "Parametr funkcji COS musi być typu FLOAT a nie typu " + TypeName(p1->type) );
																	Cast(TP_FLOAT,p1);
																	if( 0 == p1 )  throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu FLOAT" );
																}
#line 1419 "alan_parser.cc"

                    consumeToken(AlanToken::RPAR);
                    {
#line 578 "ALan.cg"
 return new AlanFuncCos(p1); }
#line 1425 "alan_parser.cc"

                  } else { 
                    if ((scanner.la()->id == AlanToken::TAN)) {
                      consumeToken(AlanToken::TAN);
                      consumeToken(AlanToken::LPAR);
                      
#line 582 "ALan.cg"
p1 = 
#line 1434 "alan_parser.cc"
Expr();
                      {
#line 582 "ALan.cg"
	if( ! TypesMatch( TP_FLOAT, p1->type ) ) throw AlanException( token->bPos.ln, token->bPos.col, "Parametr funkcji TAN musi być typu FLOAT a nie typu " + TypeName(p1->type) );
																	Cast(TP_FLOAT,p1);
																	if( 0 == p1 )  throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu FLOAT" );
																}
#line 1442 "alan_parser.cc"

                      consumeToken(AlanToken::RPAR);
                      {
#line 586 "ALan.cg"
 return new AlanFuncTan(p1); }
#line 1448 "alan_parser.cc"

                    } else { 
                      if ((scanner.la()->id == AlanToken::EXP)) {
                        consumeToken(AlanToken::EXP);
                        consumeToken(AlanToken::LPAR);
                        
#line 590 "ALan.cg"
p1 = 
#line 1457 "alan_parser.cc"
Expr();
                        {
#line 590 "ALan.cg"
	if( ! TypesMatch( TP_FLOAT, p1->type ) ) throw AlanException( token->bPos.ln, token->bPos.col, "Parametr funkcji EXP musi być typu FLOAT a nie typu " + TypeName(p1->type) );
																	Cast(TP_FLOAT,p1);
																	if( 0 == p1 )  throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu FLOAT" );
																}
#line 1465 "alan_parser.cc"

                        consumeToken(AlanToken::RPAR);
                        {
#line 594 "ALan.cg"
 return new AlanFuncExp(p1); }
#line 1471 "alan_parser.cc"

                      } else { 
                        if ((scanner.la()->id == AlanToken::LOG)) {
                          consumeToken(AlanToken::LOG);
                          consumeToken(AlanToken::LPAR);
                          
#line 598 "ALan.cg"
p1 = 
#line 1480 "alan_parser.cc"
Expr();
                          {
#line 598 "ALan.cg"
	if( ! TypesMatch( TP_FLOAT, p1->type ) ) throw AlanException( token->bPos.ln, token->bPos.col, "Parametr funkcji LOG musi być typu FLOAT a nie typu " + TypeName(p1->type) );
																	Cast(TP_FLOAT,p1);
																	if( 0 == p1 )  throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu FLOAT" );
																}
#line 1488 "alan_parser.cc"

                          consumeToken(AlanToken::RPAR);
                          {
#line 602 "ALan.cg"
 return new AlanFuncLog(p1); }
#line 1494 "alan_parser.cc"

                        } else { 
                          if ((scanner.la()->id == AlanToken::POW)) {
                            consumeToken(AlanToken::POW);
                            consumeToken(AlanToken::LPAR);
                            
#line 606 "ALan.cg"
p1 = 
#line 1503 "alan_parser.cc"
Expr();
                            {
#line 606 "ALan.cg"
	if( ! TypesMatch( TP_FLOAT, p1->type ) ) throw AlanException( token->bPos.ln, token->bPos.col, "Parametr nr 1 funkcji POW musi być typu FLOAT a nie typu " + TypeName(p1->type) );
																	Cast(TP_FLOAT,p1);
																	if( 0 == p1 )  throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu FLOAT" );
																}
#line 1511 "alan_parser.cc"

                            consumeToken(AlanToken::COMMA);
                            
#line 611 "ALan.cg"
p2 = 
#line 1517 "alan_parser.cc"
Expr();
                            {
#line 611 "ALan.cg"
	if( ! TypesMatch( TP_INT, p2->type ) ) throw AlanException( token->bPos.ln, token->bPos.col, "Parametr nr 2 funkcji POW musi być typu FLOAT a nie typu " + TypeName(p2->type) );
																	Cast(TP_FLOAT,p2);
																	if( 0 == p2 )  throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu FLOAT" );
																}
#line 1525 "alan_parser.cc"

                            consumeToken(AlanToken::RPAR);
                            {
#line 615 "ALan.cg"
 return new AlanFuncPow(p1,p2); }
#line 1531 "alan_parser.cc"

                          } else { 
                            if ((scanner.la()->id == AlanToken::SQRT)) {
                              consumeToken(AlanToken::SQRT);
                              consumeToken(AlanToken::LPAR);
                              
#line 619 "ALan.cg"
p1 = 
#line 1540 "alan_parser.cc"
Expr();
                              {
#line 619 "ALan.cg"
	if( ! TypesMatch( TP_FLOAT, p1->type ) ) throw AlanException( token->bPos.ln, token->bPos.col, "Parametr funkcji SQRT musi być typu FLOAT a nie typu " + TypeName(p1->type) );
																	Cast(TP_FLOAT,p1);
																	if( 0 == p1 )  throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu FLOAT" );
																}
#line 1548 "alan_parser.cc"

                              consumeToken(AlanToken::RPAR);
                              {
#line 623 "ALan.cg"
 return new AlanFuncSqrt(p1); }
#line 1554 "alan_parser.cc"

                            } else { 
                              if ((scanner.la()->id == AlanToken::ABS)) {
                                consumeToken(AlanToken::ABS);
                                consumeToken(AlanToken::LPAR);
                                
#line 627 "ALan.cg"
p1 = 
#line 1563 "alan_parser.cc"
Expr();
                                consumeToken(AlanToken::RPAR);
                                {
#line 628 "ALan.cg"
 if( TP_FLOAT == p1->type ) return new AlanFuncAbsF(p1);
																  if( TP_INT == p1->type ) return new AlanFuncAbsI(p1);
																	throw AlanException( token->bPos.ln, token->bPos.col, "Parametr funkcji ABS musi być typu INT lub FLOAT a nie typu " + TypeName(p1->type) );
																}
#line 1572 "alan_parser.cc"

                              } else { 
                                if ((scanner.la()->id == AlanToken::SGN)) {
                                  consumeToken(AlanToken::SGN);
                                  consumeToken(AlanToken::LPAR);
                                  
#line 635 "ALan.cg"
p1 = 
#line 1581 "alan_parser.cc"
Expr();
                                  consumeToken(AlanToken::RPAR);
                                  {
#line 636 "ALan.cg"
 if( TP_FLOAT == p1->type ) return new AlanFuncSgnF(p1);
																  if( TP_INT == p1->type ) return new AlanFuncSgnI(p1);
																	throw AlanException( token->bPos.ln, token->bPos.col, "Parametr funkcji SGN musi być typu INT lub FLOAT a nie typu " + TypeName(p1->type) );
																}
#line 1590 "alan_parser.cc"

                                } else { 
                                  if ((scanner.la()->id == AlanToken::FLOOR)) {
                                    consumeToken(AlanToken::FLOOR);
                                    consumeToken(AlanToken::LPAR);
                                    
#line 643 "ALan.cg"
p1 = 
#line 1599 "alan_parser.cc"
Expr();
                                    {
#line 643 "ALan.cg"
	if( ! TypesMatch( TP_FLOAT, p1->type ) ) throw AlanException( token->bPos.ln, token->bPos.col, "Parametr funkcji FLOOR musi być typu FLOAT a nie typu " + TypeName(p1->type) );
																	Cast(TP_FLOAT,p1);
																	if( 0 == p1 )  throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu FLOAT" );
																}
#line 1607 "alan_parser.cc"

                                    consumeToken(AlanToken::RPAR);
                                    {
#line 647 "ALan.cg"
 return new AlanFuncFloor(p1); }
#line 1613 "alan_parser.cc"

                                  } else { 
                                    if ((scanner.la()->id == AlanToken::CEIL)) {
                                      consumeToken(AlanToken::CEIL);
                                      consumeToken(AlanToken::LPAR);
                                      
#line 651 "ALan.cg"
p1 = 
#line 1622 "alan_parser.cc"
Expr();
                                      {
#line 651 "ALan.cg"
	if( ! TypesMatch( TP_FLOAT, p1->type ) ) throw AlanException( token->bPos.ln, token->bPos.col, "Parametr funkcji CEIL musi być typu FLOAT a nie typu " + TypeName(p1->type) );
																	Cast(TP_FLOAT,p1);
																	if( 0 == p1 )  throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu FLOAT" );
																}
#line 1630 "alan_parser.cc"

                                      consumeToken(AlanToken::RPAR);
                                      {
#line 655 "ALan.cg"
 return new AlanFuncCeil(p1); }
#line 1636 "alan_parser.cc"

                                    } else { 
                                      if ((scanner.la()->id == AlanToken::MIN)) {
                                        consumeToken(AlanToken::MIN);
                                        consumeToken(AlanToken::LPAR);
                                        
#line 659 "ALan.cg"
p1 = 
#line 1645 "alan_parser.cc"
Expr();
                                        consumeToken(AlanToken::COMMA);
                                        
#line 661 "ALan.cg"
p2 = 
#line 1651 "alan_parser.cc"
Expr();
                                        consumeToken(AlanToken::RPAR);
                                        {
#line 662 "ALan.cg"
 if( ! IsNumType(p1->type) )  throw AlanException( token->bPos.ln, token->bPos.col, "Parametr nr 1 funkcji MIN musi być typu numerycznego a nie typu " + TypeName(p1->type) );
																	if( ! IsNumType(p2->type) )  throw AlanException( token->bPos.ln, token->bPos.col, "Parametr nr 2 funkcji MIN musi być typu numerycznego a nie typu " + TypeName(p2->type) );
																	if( TP_INT == p1->type && TP_INT == p2->type ) return new AlanFuncMinI(p1,p2);
																	if( p1->type != p1->type ) {
																			if( ! TypesMatch( p1->type, p2->type ) ) throw AlanException( token->bPos.ln, token->bPos.col, "Funkcja MIN nie jest zdefiniowana dla wartości typów " + TypeName(p1->type) + " i " + TypeName(p2->type) );
																			Cast(p1,p2);
																			if( 0 == p1 ) throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu " + TypeName(p1->type) );
																			if( 0 == p2 ) throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu " + TypeName(p2->type) );
																	}
																	return new AlanFuncMinF(p1,p2);
																}
#line 1667 "alan_parser.cc"

                                      } else { 
                                        consumeToken(AlanToken::MAX);
                                        consumeToken(AlanToken::LPAR);
                                        
#line 676 "ALan.cg"
p1 = 
#line 1675 "alan_parser.cc"
Expr();
                                        consumeToken(AlanToken::COMMA);
                                        
#line 678 "ALan.cg"
p2 = 
#line 1681 "alan_parser.cc"
Expr();
                                        consumeToken(AlanToken::RPAR);
                                        {
#line 679 "ALan.cg"
 if( ! IsNumType(p1->type) )  throw AlanException( token->bPos.ln, token->bPos.col, "Parametr nr 1 funkcji MAX musi być typu numerycznego a nie typu " + TypeName(p1->type) );
																	if( ! IsNumType(p2->type) )  throw AlanException( token->bPos.ln, token->bPos.col, "Parametr nr 2 funkcji MAX musi być typu numerycznego a nie typu " + TypeName(p2->type) );
																	if( TP_INT == p1->type && TP_INT == p2->type ) return new AlanFuncMaxI(p1,p2);
																	if( p1->type != p1->type ) {
																			if( ! TypesMatch( p1->type, p2->type ) ) throw AlanException( token->bPos.ln, token->bPos.col, "Funkcja MAX nie jest zdefiniowana dla wartości typów " + TypeName(p1->type) + " i " + TypeName(p2->type) );
																			Cast(p1,p2);
																			if( 0 == p1 ) throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu " + TypeName(p1->type) );
																			if( 0 == p2 ) throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu " + TypeName(p2->type) );
																	}
																	return new AlanFuncMaxF(p1,p2);
																}
#line 1697 "alan_parser.cc"

                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}



#line 693 "ALan.cg"
AlanExpr* cppcc::
#line 1724 "alan_parser.cc"
AlanParser::primaryExpr ()
     throw (
#line 693 "ALan.cg"
AlanException,
#line 1729 "alan_parser.cc"
ScanException, ParseException)
{
#line 695 "ALan.cg"
 AlanVariable *var=0; AlanExpr* exp=0; ;
#line 1734 "alan_parser.cc"

  if ((scanner.la()->id == AlanToken::IDENT)) {
    
#line 696 "ALan.cg"
var = 
#line 1740 "alan_parser.cc"
Variable();
    {
#line 696 "ALan.cg"
 return var; }
#line 1745 "alan_parser.cc"

  } else { 
    if ((scanner.la()->id == AlanToken::IS) || (scanner.la()->id == AlanToken::MOUSE) || (scanner.la()->id == AlanToken::STRLEN) || (scanner.la()->id == AlanToken::SUBSTR) || (scanner.la()->id == AlanToken::INSTR) || (scanner.la()->id == AlanToken::RAND) || (scanner.la()->id == AlanToken::RANDF) || (scanner.la()->id == AlanToken::SIN) || (scanner.la()->id == AlanToken::COS) || (scanner.la()->id == AlanToken::TAN) || (scanner.la()->id == AlanToken::EXP) || (scanner.la()->id == AlanToken::LOG) || (scanner.la()->id == AlanToken::POW) || (scanner.la()->id == AlanToken::SQRT) || (scanner.la()->id == AlanToken::ABS) || (scanner.la()->id == AlanToken::SGN) || (scanner.la()->id == AlanToken::FLOOR) || (scanner.la()->id == AlanToken::CEIL) || (scanner.la()->id == AlanToken::MIN) || (scanner.la()->id == AlanToken::MAX)) {
      
#line 697 "ALan.cg"
exp = 
#line 1752 "alan_parser.cc"
buildinFunc();
      {
#line 697 "ALan.cg"
 return exp; }
#line 1757 "alan_parser.cc"

    } else { 
      if ((scanner.la()->id == AlanToken::TRUE) || (scanner.la()->id == AlanToken::FALSE) || (scanner.la()->id == AlanToken::DEC_CONSTANT) || (scanner.la()->id == AlanToken::FLOAT_CONSTANT) || (scanner.la()->id == AlanToken::STRING_LITERAL)) {
        
#line 698 "ALan.cg"
exp = 
#line 1764 "alan_parser.cc"
Constant();
        {
#line 698 "ALan.cg"
 return exp; }
#line 1769 "alan_parser.cc"

      } else { 
        consumeToken(AlanToken::LPAR);
        
#line 699 "ALan.cg"
exp = 
#line 1776 "alan_parser.cc"
Expr();
        consumeToken(AlanToken::RPAR);
        {
#line 699 "ALan.cg"
 return exp; }
#line 1782 "alan_parser.cc"

      }
    }
  }
}



#line 702 "ALan.cg"
AlanExpr* cppcc::
#line 1793 "alan_parser.cc"
AlanParser::unaryExpr ()
     throw (
#line 702 "ALan.cg"
AlanException,
#line 1798 "alan_parser.cc"
ScanException, ParseException)
{
#line 704 "ALan.cg"
 AlanExpr* exp=0; ;
#line 1803 "alan_parser.cc"

  if ((scanner.la()->id == AlanToken::LPAR) || (scanner.la()->id == AlanToken::TRUE) || (scanner.la()->id == AlanToken::FALSE) || (scanner.la()->id == AlanToken::IS) || (scanner.la()->id == AlanToken::MOUSE) || (scanner.la()->id == AlanToken::STRLEN) || (scanner.la()->id == AlanToken::SUBSTR) || (scanner.la()->id == AlanToken::INSTR) || (scanner.la()->id == AlanToken::RAND) || (scanner.la()->id == AlanToken::RANDF) || (scanner.la()->id == AlanToken::SIN) || (scanner.la()->id == AlanToken::COS) || (scanner.la()->id == AlanToken::TAN) || (scanner.la()->id == AlanToken::EXP) || (scanner.la()->id == AlanToken::LOG) || (scanner.la()->id == AlanToken::POW) || (scanner.la()->id == AlanToken::SQRT) || (scanner.la()->id == AlanToken::ABS) || (scanner.la()->id == AlanToken::SGN) || (scanner.la()->id == AlanToken::FLOOR) || (scanner.la()->id == AlanToken::CEIL) || (scanner.la()->id == AlanToken::MIN) || (scanner.la()->id == AlanToken::MAX) || (scanner.la()->id == AlanToken::DEC_CONSTANT) || (scanner.la()->id == AlanToken::FLOAT_CONSTANT) || (scanner.la()->id == AlanToken::STRING_LITERAL) || (scanner.la()->id == AlanToken::IDENT)) {
    
#line 705 "ALan.cg"
exp = 
#line 1809 "alan_parser.cc"
primaryExpr();
    {
#line 705 "ALan.cg"
 return exp; }
#line 1814 "alan_parser.cc"

  } else { 
    if ((scanner.la()->id == AlanToken::MINUS)) {
      consumeToken(AlanToken::MINUS);
      
#line 706 "ALan.cg"
exp = 
#line 1822 "alan_parser.cc"
unaryExpr();
      {
#line 706 "ALan.cg"
 return new AlanExprNeg(exp); }
#line 1827 "alan_parser.cc"

    } else { 
      consumeToken(AlanToken::PLUS);
      
#line 707 "ALan.cg"
exp = 
#line 1834 "alan_parser.cc"
unaryExpr();
      {
#line 707 "ALan.cg"
 return exp; }
#line 1839 "alan_parser.cc"

    }
  }
}



#line 710 "ALan.cg"
AlanExpr* cppcc::
#line 1849 "alan_parser.cc"
AlanParser::castExpr ()
     throw (
#line 710 "ALan.cg"
AlanException,
#line 1854 "alan_parser.cc"
ScanException, ParseException)
{
#line 712 "ALan.cg"
 AlanExpr* exp=0; ;
#line 1859 "alan_parser.cc"

  if ((scanner.la()->id == AlanToken::LPAR) || (scanner.la()->id == AlanToken::PLUS) || (scanner.la()->id == AlanToken::MINUS) || (scanner.la()->id == AlanToken::TRUE) || (scanner.la()->id == AlanToken::FALSE) || (scanner.la()->id == AlanToken::IS) || (scanner.la()->id == AlanToken::MOUSE) || (scanner.la()->id == AlanToken::STRLEN) || (scanner.la()->id == AlanToken::SUBSTR) || (scanner.la()->id == AlanToken::INSTR) || (scanner.la()->id == AlanToken::RAND) || (scanner.la()->id == AlanToken::RANDF) || (scanner.la()->id == AlanToken::SIN) || (scanner.la()->id == AlanToken::COS) || (scanner.la()->id == AlanToken::TAN) || (scanner.la()->id == AlanToken::EXP) || (scanner.la()->id == AlanToken::LOG) || (scanner.la()->id == AlanToken::POW) || (scanner.la()->id == AlanToken::SQRT) || (scanner.la()->id == AlanToken::ABS) || (scanner.la()->id == AlanToken::SGN) || (scanner.la()->id == AlanToken::FLOOR) || (scanner.la()->id == AlanToken::CEIL) || (scanner.la()->id == AlanToken::MIN) || (scanner.la()->id == AlanToken::MAX) || (scanner.la()->id == AlanToken::DEC_CONSTANT) || (scanner.la()->id == AlanToken::FLOAT_CONSTANT) || (scanner.la()->id == AlanToken::STRING_LITERAL) || (scanner.la()->id == AlanToken::IDENT)) {
    
#line 713 "ALan.cg"
exp = 
#line 1865 "alan_parser.cc"
unaryExpr();
    {
#line 713 "ALan.cg"
 return exp; }
#line 1870 "alan_parser.cc"

  } else { 
    if ((scanner.la()->id == AlanToken::BOOL)) {
      consumeToken(AlanToken::BOOL);
      consumeToken(AlanToken::LPAR);
      
#line 714 "ALan.cg"
exp = 
#line 1879 "alan_parser.cc"
castExpr();
      consumeToken(AlanToken::RPAR);
      {
#line 714 "ALan.cg"
 return new AlanExprCastBool(exp); }
#line 1885 "alan_parser.cc"

    } else { 
      if ((scanner.la()->id == AlanToken::INT)) {
        consumeToken(AlanToken::INT);
        consumeToken(AlanToken::LPAR);
        
#line 715 "ALan.cg"
exp = 
#line 1894 "alan_parser.cc"
castExpr();
        consumeToken(AlanToken::RPAR);
        {
#line 715 "ALan.cg"
 return new AlanExprCastInt(exp); }
#line 1900 "alan_parser.cc"

      } else { 
        if ((scanner.la()->id == AlanToken::FLOAT)) {
          consumeToken(AlanToken::FLOAT);
          consumeToken(AlanToken::LPAR);
          
#line 716 "ALan.cg"
exp = 
#line 1909 "alan_parser.cc"
castExpr();
          consumeToken(AlanToken::RPAR);
          {
#line 716 "ALan.cg"
 return new AlanExprCastFloat(exp); }
#line 1915 "alan_parser.cc"

        } else { 
          consumeToken(AlanToken::STRING);
          consumeToken(AlanToken::LPAR);
          
#line 717 "ALan.cg"
exp = 
#line 1923 "alan_parser.cc"
castExpr();
          consumeToken(AlanToken::RPAR);
          {
#line 717 "ALan.cg"
 return new AlanExprCastString(exp); }
#line 1929 "alan_parser.cc"

        }
      }
    }
  }
}



#line 720 "ALan.cg"
AlanExpr* cppcc::
#line 1941 "alan_parser.cc"
AlanParser::multiplicativeExpr ()
     throw (
#line 720 "ALan.cg"
AlanException,
#line 1946 "alan_parser.cc"
ScanException, ParseException)
{
#line 722 "ALan.cg"
 AlanExpr *exp=0, *exp2=0; ;
#line 1951 "alan_parser.cc"

  
#line 723 "ALan.cg"
exp = 
#line 1956 "alan_parser.cc"
castExpr();
  while ((scanner.la()->id == AlanToken::MUL) || (scanner.la()->id == AlanToken::DIV) || (scanner.la()->id == AlanToken::MOD)) {
    if ((scanner.la()->id == AlanToken::MUL)) {
      consumeToken(AlanToken::MUL);
      
#line 724 "ALan.cg"
exp2 = 
#line 1964 "alan_parser.cc"
castExpr();
      {
#line 724 "ALan.cg"
 if( ! IsNumType(exp->type) )  throw AlanException( token->bPos.ln, token->bPos.col, "Operator * nie jest zdefiniowany dla wartości typu " + TypeName(exp->type) );
																		if( ! IsNumType(exp2->type) ) throw AlanException( token->bPos.ln, token->bPos.col, "Operator * nie jest zdefiniowany dla wartości typu " + TypeName(exp2->type) );
																		if( exp2->type != exp->type ) {
																			if( ! TypesMatch( exp->type, exp2->type ) ) throw AlanException( token->bPos.ln, token->bPos.col, "Operator * nie jest zdefiniowany dla wartości typów " + TypeName(exp->type) + " i " + TypeName(exp2->type) );
																			Cast(exp,exp2);
																			if( 0 == exp )  throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu " + TypeName(exp->type) );
																			if( 0 == exp2 ) throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu " + TypeName(exp2->type) );
																		}
																		exp = new AlanExprMul(exp,exp2);
																	}
#line 1978 "alan_parser.cc"

    } else { 
      if ((scanner.la()->id == AlanToken::DIV)) {
        consumeToken(AlanToken::DIV);
        
#line 734 "ALan.cg"
exp2 = 
#line 1986 "alan_parser.cc"
castExpr();
        {
#line 734 "ALan.cg"
 if( ! IsNumType(exp->type) )  throw AlanException( token->bPos.ln, token->bPos.col, "Operator / nie jest zdefiniowany dla wartości typu " + TypeName(exp->type) );
																		if( ! IsNumType(exp2->type) ) throw AlanException( token->bPos.ln, token->bPos.col, "Operator / nie jest zdefiniowany dla wartości typu " + TypeName(exp2->type) );
																		if( exp2->type != exp->type ) {
																			if( ! TypesMatch( exp->type, exp2->type ) ) throw AlanException( token->bPos.ln, token->bPos.col, "Operator / nie jest zdefiniowany dla wartości typów " + TypeName(exp->type) + " i " + TypeName(exp2->type) );
																			Cast(exp,exp2);
																			if( 0 == exp )  throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu " + TypeName(exp->type) );
																			if( 0 == exp2 ) throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu " + TypeName(exp2->type) );
																		}
																		exp = new AlanExprDiv(exp,exp2);
																	}
#line 2000 "alan_parser.cc"

      } else { 
        consumeToken(AlanToken::MOD);
        
#line 744 "ALan.cg"
exp2 = 
#line 2007 "alan_parser.cc"
castExpr();
        {
#line 744 "ALan.cg"
 if( ! IsNumType(exp->type) )  throw AlanException( token->bPos.ln, token->bPos.col, "Operator % nie jest zdefiniowany dla wartości typu " + TypeName(exp->type) );
																		if( ! IsNumType(exp2->type) ) throw AlanException( token->bPos.ln, token->bPos.col, "Operator % nie jest zdefiniowany dla wartości typu " + TypeName(exp2->type) );
																		if( exp2->type != exp->type ) {
																			if( ! TypesMatch( exp->type, exp2->type ) ) throw AlanException( token->bPos.ln, token->bPos.col, "Operator % nie jest zdefiniowany dla wartości typów " + TypeName(exp->type) + " i " + TypeName(exp2->type) );
																			Cast(exp,exp2);
																			if( 0 == exp )  throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu " + TypeName(exp->type) );
																			if( 0 == exp2 ) throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu " + TypeName(exp2->type) );
																		}
																		exp = new AlanExprMod(exp,exp2);
																	}
#line 2021 "alan_parser.cc"

      }
    }
  }
  {
#line 755 "ALan.cg"
 return exp; }
#line 2029 "alan_parser.cc"

}



#line 759 "ALan.cg"
AlanExpr* cppcc::
#line 2037 "alan_parser.cc"
AlanParser::additiveExpr ()
     throw (
#line 759 "ALan.cg"
AlanException,
#line 2042 "alan_parser.cc"
ScanException, ParseException)
{
#line 761 "ALan.cg"
 AlanExpr *exp=0, *exp2=0; ;
#line 2047 "alan_parser.cc"

  
#line 762 "ALan.cg"
exp = 
#line 2052 "alan_parser.cc"
multiplicativeExpr();
  while ((scanner.la()->id == AlanToken::PLUS) || (scanner.la()->id == AlanToken::MINUS)) {
    if ((scanner.la()->id == AlanToken::PLUS)) {
      consumeToken(AlanToken::PLUS);
      
#line 763 "ALan.cg"
exp2 = 
#line 2060 "alan_parser.cc"
multiplicativeExpr();
      {
#line 763 "ALan.cg"
 if( ! IsNumType(exp->type)  && exp->type != TP_STRING )  throw AlanException( token->bPos.ln, token->bPos.col, "Operator * nie jest zdefiniowany dla wartości typu " + TypeName(exp->type) );
																								if( ! IsNumType(exp2->type) && exp2->type != TP_STRING ) throw AlanException( token->bPos.ln, token->bPos.col, "Operator * nie jest zdefiniowany dla wartości typu " + TypeName(exp2->type) );
																								if( exp2->type != exp->type ) {
																									if( ! TypesMatch( exp->type, exp2->type ) ) throw AlanException( token->bPos.ln, token->bPos.col, "Operator * nie jest zdefiniowany dla wartości typów " + TypeName(exp->type) + " i " + TypeName(exp2->type) );
																									Cast(exp,exp2);
																									if( 0 == exp )  throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu " + TypeName(exp->type) );
																									if( 0 == exp2 ) throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu " + TypeName(exp2->type) );
																								}
																								exp = new AlanExprAdd(exp,exp2);
																							}
#line 2074 "alan_parser.cc"

    } else { 
      consumeToken(AlanToken::MINUS);
      
#line 773 "ALan.cg"
exp2 = 
#line 2081 "alan_parser.cc"
multiplicativeExpr();
      {
#line 773 "ALan.cg"
 if( ! IsNumType(exp->type) )  throw AlanException( token->bPos.ln, token->bPos.col, "Operator * nie jest zdefiniowany dla wartości typu " + TypeName(exp->type) );
																								if( ! IsNumType(exp2->type) ) throw AlanException( token->bPos.ln, token->bPos.col, "Operator * nie jest zdefiniowany dla wartości typu " + TypeName(exp2->type) );
																								if( exp2->type != exp->type ) {
																									if( ! TypesMatch( exp->type, exp2->type ) ) throw AlanException( token->bPos.ln, token->bPos.col, "Operator * nie jest zdefiniowany dla wartości typów " + TypeName(exp->type) + " i " + TypeName(exp2->type) );
																									Cast(exp,exp2);
																									if( 0 == exp )  throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu " + TypeName(exp->type) );
																									if( 0 == exp2 ) throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu " + TypeName(exp2->type) );
																								}
																								exp = new AlanExprSub(exp,exp2);
																							}
#line 2095 "alan_parser.cc"

    }
  }
  {
#line 784 "ALan.cg"
 return exp; }
#line 2102 "alan_parser.cc"

}



#line 787 "ALan.cg"
AlanExpr* cppcc::
#line 2110 "alan_parser.cc"
AlanParser::relExpr ()
     throw (
#line 787 "ALan.cg"
AlanException,
#line 2115 "alan_parser.cc"
ScanException, ParseException)
{
#line 788 "ALan.cg"
 AlanExpr *exp = 0, *exp2 = 0; int op;	string op_tok = ""; ;
#line 2120 "alan_parser.cc"

  
#line 789 "ALan.cg"
exp = 
#line 2125 "alan_parser.cc"
additiveExpr();
  while ((scanner.la()->id == AlanToken::ASSIGN) || (scanner.la()->id == AlanToken::LT) || (scanner.la()->id == AlanToken::GT) || (scanner.la()->id == AlanToken::LE) || (scanner.la()->id == AlanToken::GE) || (scanner.la()->id == AlanToken::NE)) {
    
#line 790 "ALan.cg"
op = 
#line 2131 "alan_parser.cc"
RelOp2(
#line 790 "ALan.cg"
op_tok);
#line 2135 "alan_parser.cc"

    
#line 791 "ALan.cg"
exp2 = 
#line 2140 "alan_parser.cc"
additiveExpr();
    {
#line 791 "ALan.cg"
 if( op > 1 ) {
																	if( ! IsRelType(exp->type) )  throw AlanException( token->bPos.ln, token->bPos.col, "Operator " + op_tok + " nie jest zdefiniowany dla wartości typu " + TypeName(exp->type) );
																	if( ! IsRelType(exp2->type) ) throw AlanException( token->bPos.ln, token->bPos.col, "Operator " + op_tok + " nie jest zdefiniowany dla wartości typu " + TypeName(exp->type) );
																}
																if( exp2->type != exp->type ) {
																	if( ! TypesMatch( exp->type, exp2->type ) ) throw AlanException( token->bPos.ln, token->bPos.col, "Operator * nie jest zdefiniowany dla wartości typów " + TypeName(exp->type) + " i " + TypeName(exp2->type) );
																	Cast(exp,exp2);
																	if( 0 == exp )  throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu " + TypeName(exp->type) );
																	if( 0 == exp2 ) throw AlanException( token->bPos.ln, token->bPos.col, "Nie ma możliwości rzutowania wartości do typu " + TypeName(exp2->type) );
																}
																switch( op ) {
																	case 0: exp = new AlanExprEq(exp,exp2); break;
																	case 1: exp = new AlanExprNe(exp,exp2); break;
																	case 2: exp = new AlanExprLt(exp,exp2); break;
																	case 3: exp = new AlanExprGt(exp,exp2); break;
																	case 4: exp = new AlanExprLe(exp,exp2); break;
																	case 5: exp = new AlanExprGe(exp,exp2); break;
																	default: throw AlanException( token->bPos.ln, token->bPos.col, "Nieznany operator relacyjny" ); break;
																}
															}
#line 2164 "alan_parser.cc"

  }
  {
#line 812 "ALan.cg"
 return exp; }
#line 2170 "alan_parser.cc"

}



#line 815 "ALan.cg"
int cppcc::
#line 2178 "alan_parser.cc"
AlanParser::RelOp2 (
#line 815 "ALan.cg"
string& tok)
#line 2182 "alan_parser.cc"

     throw (
#line 815 "ALan.cg"
AlanException,
#line 2187 "alan_parser.cc"
ScanException, ParseException)
{
  if ((scanner.la()->id == AlanToken::ASSIGN)) {
    consumeToken(AlanToken::ASSIGN);
    {
#line 817 "ALan.cg"
 tok = token->image(); return 0; }
#line 2195 "alan_parser.cc"

  } else { 
    if ((scanner.la()->id == AlanToken::NE)) {
      consumeToken(AlanToken::NE);
      {
#line 818 "ALan.cg"
 tok = token->image(); return 1; }
#line 2203 "alan_parser.cc"

    } else { 
      if ((scanner.la()->id == AlanToken::LT)) {
        consumeToken(AlanToken::LT);
        {
#line 819 "ALan.cg"
 tok = token->image(); return 2; }
#line 2211 "alan_parser.cc"

      } else { 
        if ((scanner.la()->id == AlanToken::GT)) {
          consumeToken(AlanToken::GT);
          {
#line 820 "ALan.cg"
 tok = token->image(); return 3; }
#line 2219 "alan_parser.cc"

        } else { 
          if ((scanner.la()->id == AlanToken::LE)) {
            consumeToken(AlanToken::LE);
            {
#line 821 "ALan.cg"
 tok = token->image(); return 4; }
#line 2227 "alan_parser.cc"

          } else { 
            consumeToken(AlanToken::GE);
            {
#line 822 "ALan.cg"
 tok = token->image(); return 5; }
#line 2234 "alan_parser.cc"

          }
        }
      }
    }
  }
}



#line 825 "ALan.cg"
AlanExpr* cppcc::
#line 2247 "alan_parser.cc"
AlanParser::unaryBoolExpr ()
     throw (
#line 825 "ALan.cg"
AlanException,
#line 2252 "alan_parser.cc"
ScanException, ParseException)
{
#line 827 "ALan.cg"
 AlanExpr* exp=0; ;
#line 2257 "alan_parser.cc"

  if ((scanner.la()->id == AlanToken::LPAR) || (scanner.la()->id == AlanToken::PLUS) || (scanner.la()->id == AlanToken::MINUS) || (scanner.la()->id == AlanToken::TRUE) || (scanner.la()->id == AlanToken::FALSE) || (scanner.la()->id == AlanToken::BOOL) || (scanner.la()->id == AlanToken::INT) || (scanner.la()->id == AlanToken::FLOAT) || (scanner.la()->id == AlanToken::STRING) || (scanner.la()->id == AlanToken::IS) || (scanner.la()->id == AlanToken::MOUSE) || (scanner.la()->id == AlanToken::STRLEN) || (scanner.la()->id == AlanToken::SUBSTR) || (scanner.la()->id == AlanToken::INSTR) || (scanner.la()->id == AlanToken::RAND) || (scanner.la()->id == AlanToken::RANDF) || (scanner.la()->id == AlanToken::SIN) || (scanner.la()->id == AlanToken::COS) || (scanner.la()->id == AlanToken::TAN) || (scanner.la()->id == AlanToken::EXP) || (scanner.la()->id == AlanToken::LOG) || (scanner.la()->id == AlanToken::POW) || (scanner.la()->id == AlanToken::SQRT) || (scanner.la()->id == AlanToken::ABS) || (scanner.la()->id == AlanToken::SGN) || (scanner.la()->id == AlanToken::FLOOR) || (scanner.la()->id == AlanToken::CEIL) || (scanner.la()->id == AlanToken::MIN) || (scanner.la()->id == AlanToken::MAX) || (scanner.la()->id == AlanToken::DEC_CONSTANT) || (scanner.la()->id == AlanToken::FLOAT_CONSTANT) || (scanner.la()->id == AlanToken::STRING_LITERAL) || (scanner.la()->id == AlanToken::IDENT)) {
    
#line 828 "ALan.cg"
exp = 
#line 2263 "alan_parser.cc"
relExpr();
    {
#line 828 "ALan.cg"
 return exp; }
#line 2268 "alan_parser.cc"

  } else { 
    consumeToken(AlanToken::NOT);
    
#line 829 "ALan.cg"
exp = 
#line 2275 "alan_parser.cc"
unaryBoolExpr();
    {
#line 829 "ALan.cg"
	if( exp->type != TP_BOOL ) throw AlanException( token->bPos.ln, token->bPos.col, "Operator NOT nie jest zdefiniowany dla wartości typu " + TypeName(exp->type) );
																				return new AlanExprNot(exp);
																			}
#line 2282 "alan_parser.cc"

  }
}



#line 834 "ALan.cg"
AlanExpr* cppcc::
#line 2291 "alan_parser.cc"
AlanParser::mulBoolExpr ()
     throw (
#line 834 "ALan.cg"
AlanException,
#line 2296 "alan_parser.cc"
ScanException, ParseException)
{
#line 836 "ALan.cg"
 AlanExpr *exp=0, *exp2=0; ;
#line 2301 "alan_parser.cc"

  
#line 837 "ALan.cg"
exp = 
#line 2306 "alan_parser.cc"
unaryBoolExpr();
  while ((scanner.la()->id == AlanToken::AND)) {
    consumeToken(AlanToken::AND);
    
#line 838 "ALan.cg"
exp2 = 
#line 2313 "alan_parser.cc"
unaryBoolExpr();
    {
#line 838 "ALan.cg"
	if( exp->type != TP_BOOL )  throw AlanException( token->bPos.ln, token->bPos.col, "Operator AND nie jest zdefiniowany dla wartości typu " + TypeName(exp->type) );
																					if( exp2->type != TP_BOOL ) throw AlanException( token->bPos.ln, token->bPos.col, "Operator AND nie jest zdefiniowany dla wartości typu " + TypeName(exp2->type) );
																					exp = new AlanExprAnd(exp,exp2);
																				}
#line 2321 "alan_parser.cc"

  }
  {
#line 843 "ALan.cg"
 return exp; }
#line 2327 "alan_parser.cc"

}



#line 846 "ALan.cg"
AlanExpr* cppcc::
#line 2335 "alan_parser.cc"
AlanParser::addBoolExpr ()
     throw (
#line 846 "ALan.cg"
AlanException,
#line 2340 "alan_parser.cc"
ScanException, ParseException)
{
#line 848 "ALan.cg"
 AlanExpr *exp=0, *exp2=0; ;
#line 2345 "alan_parser.cc"

  
#line 849 "ALan.cg"
exp = 
#line 2350 "alan_parser.cc"
mulBoolExpr();
  while ((scanner.la()->id == AlanToken::OR)) {
    consumeToken(AlanToken::OR);
    
#line 850 "ALan.cg"
exp2 = 
#line 2357 "alan_parser.cc"
mulBoolExpr();
    {
#line 850 "ALan.cg"
	if( exp->type != TP_BOOL )  throw AlanException( token->bPos.ln, token->bPos.col, "Operator OR nie jest zdefiniowany dla wartości typu " + TypeName(exp->type) );
																			if( exp2->type != TP_BOOL ) throw AlanException( token->bPos.ln, token->bPos.col, "Operator OR nie jest zdefiniowany dla wartości typu " + TypeName(exp2->type) );
																			exp = new AlanExprOr(exp,exp2);
																		}
#line 2365 "alan_parser.cc"

  }
  {
#line 855 "ALan.cg"
 return exp; }
#line 2371 "alan_parser.cc"

}



#line 858 "ALan.cg"
AlanExpr* cppcc::
#line 2379 "alan_parser.cc"
AlanParser::Expr ()
     throw (
#line 858 "ALan.cg"
AlanException,
#line 2384 "alan_parser.cc"
ScanException, ParseException)
{
#line 860 "ALan.cg"
 AlanExpr* exp=0; ;
#line 2389 "alan_parser.cc"

  
#line 861 "ALan.cg"
exp = 
#line 2394 "alan_parser.cc"
addBoolExpr();
  {
#line 861 "ALan.cg"
 return exp; }
#line 2399 "alan_parser.cc"

}



#line 864 "ALan.cg"
float cppcc::
#line 2407 "alan_parser.cc"
AlanParser::FloatConstant ()
     throw (
#line 864 "ALan.cg"
AlanException,
#line 2412 "alan_parser.cc"
ScanException, ParseException)
{
  consumeToken(AlanToken::FLOAT_CONSTANT);
  {
#line 866 "ALan.cg"
 return atof(token->image().c_str()); }
#line 2419 "alan_parser.cc"

}



#line 869 "ALan.cg"
int cppcc::
#line 2427 "alan_parser.cc"
AlanParser::DecConstant ()
     throw (
#line 869 "ALan.cg"
AlanException,
#line 2432 "alan_parser.cc"
ScanException, ParseException)
{
  consumeToken(AlanToken::DEC_CONSTANT);
  {
#line 871 "ALan.cg"
 return atol(token->image().c_str()); }
#line 2439 "alan_parser.cc"

}



#line 874 "ALan.cg"
bool cppcc::
#line 2447 "alan_parser.cc"
AlanParser::BoolConstant ()
     throw (
#line 874 "ALan.cg"
AlanException,
#line 2452 "alan_parser.cc"
ScanException, ParseException)
{
  if ((scanner.la()->id == AlanToken::TRUE)) {
    consumeToken(AlanToken::TRUE);
    {
#line 876 "ALan.cg"
 return true; }
#line 2460 "alan_parser.cc"

  } else { 
    consumeToken(AlanToken::FALSE);
    {
#line 877 "ALan.cg"
 return false; }
#line 2467 "alan_parser.cc"

  }
}



#line 880 "ALan.cg"
string cppcc::
#line 2476 "alan_parser.cc"
AlanParser::StringConstant ()
     throw (
#line 880 "ALan.cg"
AlanException,
#line 2481 "alan_parser.cc"
ScanException, ParseException)
{
  consumeToken(AlanToken::STRING_LITERAL);
  {
#line 882 "ALan.cg"
 return token->image().substr(1,token->image().size()-2); }
#line 2488 "alan_parser.cc"

}



#line 885 "ALan.cg"
AlanExpr* cppcc::
#line 2496 "alan_parser.cc"
AlanParser::Constant ()
     throw (
#line 885 "ALan.cg"
AlanException,
#line 2501 "alan_parser.cc"
ScanException, ParseException)
{
#line 886 "ALan.cg"
 float fval; int ival; bool bval; string sval; ;
#line 2506 "alan_parser.cc"

  if ((scanner.la()->id == AlanToken::FLOAT_CONSTANT)) {
    
#line 887 "ALan.cg"
fval = 
#line 2512 "alan_parser.cc"
FloatConstant();
    {
#line 887 "ALan.cg"
 return new AlanConstant(fval); }
#line 2517 "alan_parser.cc"

  } else { 
    if ((scanner.la()->id == AlanToken::DEC_CONSTANT)) {
      
#line 888 "ALan.cg"
ival = 
#line 2524 "alan_parser.cc"
DecConstant();
      {
#line 888 "ALan.cg"
 return new AlanConstant(ival); }
#line 2529 "alan_parser.cc"

    } else { 
      if ((scanner.la()->id == AlanToken::TRUE) || (scanner.la()->id == AlanToken::FALSE)) {
        
#line 889 "ALan.cg"
bval = 
#line 2536 "alan_parser.cc"
BoolConstant();
        {
#line 889 "ALan.cg"
 return new AlanConstant(bval); }
#line 2541 "alan_parser.cc"

      } else { 
        
#line 890 "ALan.cg"
sval = 
#line 2547 "alan_parser.cc"
StringConstant();
        {
#line 890 "ALan.cg"
 return new AlanConstant(sval); }
#line 2552 "alan_parser.cc"

      }
    }
  }
}


bool cppcc::AlanParser::__la_parse_ () throw (ScanException)
{
  if (!__la_lista_instrukcji_()) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  if (!laConsumeToken(AlanToken::eof)) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  
  __lookahead_succeed_:
    return true;
    
  __lookahead_fail_:
    return false;
}


bool cppcc::AlanParser::__la_lista_instrukcji_ () throw (ScanException)
{
  while ((scanner.la()->id == AlanToken::BOOL) || (scanner.la()->id == AlanToken::INT) || (scanner.la()->id == AlanToken::FLOAT) || (scanner.la()->id == AlanToken::STRING) || (scanner.la()->id == AlanToken::MOVE) || (scanner.la()->id == AlanToken::ANIM) || (scanner.la()->id == AlanToken::SCALE) || (scanner.la()->id == AlanToken::GOTO) || (scanner.la()->id == AlanToken::GOSUB) || (scanner.la()->id == AlanToken::RETURN) || (scanner.la()->id == AlanToken::FOR) || (scanner.la()->id == AlanToken::NEXT) || (scanner.la()->id == AlanToken::WHILE) || (scanner.la()->id == AlanToken::WEND) || (scanner.la()->id == AlanToken::IF) || (scanner.la()->id == AlanToken::ELSE) || (scanner.la()->id == AlanToken::EIF) || (scanner.la()->id == AlanToken::PAUSE) || (scanner.la()->id == AlanToken::IDENT)) {
    if (__la_0_(2147483647)) {
      if (!__la_label_()) goto __lookahead_fail_;
      if (_la == 0) goto __lookahead_succeed_;
    } else { 
      if (!__la_pojedyncza_instrukcja_()) goto __lookahead_fail_;
      if (_la == 0) goto __lookahead_succeed_;
    }
  }
  
  __lookahead_succeed_:
    return true;
    
  __lookahead_fail_:
    return false;
}


bool cppcc::AlanParser::__la_0_ (int depth) throw (ScanException)
{
  int _laSave = _la;
  _la = depth;
  scanner.setMarker();
  
  if (!__la_label_()) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  goto __lookahead_succeed_;
  
__lookahead_fail_:
  _la = _laSave;
  scanner.rewindToMarker();
  return false;

__lookahead_succeed_:
  _la = _laSave;
  scanner.rewindToMarker();
  return true;
}


bool cppcc::AlanParser::__la_label_ () throw (ScanException)
{
  if (!laConsumeToken(AlanToken::IDENT)) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  if (!laConsumeToken(AlanToken::SEMICOLON)) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  
  __lookahead_succeed_:
    return true;
    
  __lookahead_fail_:
    return false;
}


bool cppcc::AlanParser::__la_pojedyncza_instrukcja_ () throw (ScanException)
{
  if ((scanner.la()->id == AlanToken::BOOL) || (scanner.la()->id == AlanToken::INT) || (scanner.la()->id == AlanToken::FLOAT) || (scanner.la()->id == AlanToken::STRING)) {
    if (!__la_declaration_()) goto __lookahead_fail_;
    if (_la == 0) goto __lookahead_succeed_;
  } else { 
    if ((scanner.la()->id == AlanToken::MOVE)) {
      if (!__la_instr_move_()) goto __lookahead_fail_;
      if (_la == 0) goto __lookahead_succeed_;
    } else { 
      if ((scanner.la()->id == AlanToken::ANIM)) {
        if (!__la_instr_anim_()) goto __lookahead_fail_;
        if (_la == 0) goto __lookahead_succeed_;
      } else { 
        if ((scanner.la()->id == AlanToken::SCALE)) {
          if (!__la_instr_scale_()) goto __lookahead_fail_;
          if (_la == 0) goto __lookahead_succeed_;
        } else { 
          if ((scanner.la()->id == AlanToken::GOTO)) {
            if (!__la_instr_goto_()) goto __lookahead_fail_;
            if (_la == 0) goto __lookahead_succeed_;
          } else { 
            if ((scanner.la()->id == AlanToken::GOSUB)) {
              if (!__la_instr_gosub_()) goto __lookahead_fail_;
              if (_la == 0) goto __lookahead_succeed_;
            } else { 
              if ((scanner.la()->id == AlanToken::RETURN)) {
                if (!__la_instr_return_()) goto __lookahead_fail_;
                if (_la == 0) goto __lookahead_succeed_;
              } else { 
                if ((scanner.la()->id == AlanToken::IDENT)) {
                  if (!__la_instr_let_()) goto __lookahead_fail_;
                  if (_la == 0) goto __lookahead_succeed_;
                } else { 
                  if ((scanner.la()->id == AlanToken::FOR)) {
                    if (!__la_instr_for_()) goto __lookahead_fail_;
                    if (_la == 0) goto __lookahead_succeed_;
                  } else { 
                    if ((scanner.la()->id == AlanToken::NEXT)) {
                      if (!__la_instr_next_()) goto __lookahead_fail_;
                      if (_la == 0) goto __lookahead_succeed_;
                    } else { 
                      if ((scanner.la()->id == AlanToken::WHILE)) {
                        if (!__la_instr_while_()) goto __lookahead_fail_;
                        if (_la == 0) goto __lookahead_succeed_;
                      } else { 
                        if ((scanner.la()->id == AlanToken::WEND)) {
                          if (!__la_instr_wend_()) goto __lookahead_fail_;
                          if (_la == 0) goto __lookahead_succeed_;
                        } else { 
                          if ((scanner.la()->id == AlanToken::IF)) {
                            if (!__la_instr_if_()) goto __lookahead_fail_;
                            if (_la == 0) goto __lookahead_succeed_;
                          } else { 
                            if ((scanner.la()->id == AlanToken::ELSE)) {
                              if (!__la_instr_else_()) goto __lookahead_fail_;
                              if (_la == 0) goto __lookahead_succeed_;
                            } else { 
                              if ((scanner.la()->id == AlanToken::EIF)) {
                                if (!__la_instr_eif_()) goto __lookahead_fail_;
                                if (_la == 0) goto __lookahead_succeed_;
                              } else { 
                                if (!__la_instr_pause_()) goto __lookahead_fail_;
                                if (_la == 0) goto __lookahead_succeed_;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
  __lookahead_succeed_:
    return true;
    
  __lookahead_fail_:
    return false;
}


bool cppcc::AlanParser::__la_declaration_ () throw (ScanException)
{
  if (!__la_typeID_()) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  if (!__la_declVarList_()) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  
  __lookahead_succeed_:
    return true;
    
  __lookahead_fail_:
    return false;
}


bool cppcc::AlanParser::__la_typeID_ () throw (ScanException)
{
  if ((scanner.la()->id == AlanToken::BOOL)) {
    if (!laConsumeToken(AlanToken::BOOL)) goto __lookahead_fail_;
    if (_la == 0) goto __lookahead_succeed_;
  } else { 
    if ((scanner.la()->id == AlanToken::INT)) {
      if (!laConsumeToken(AlanToken::INT)) goto __lookahead_fail_;
      if (_la == 0) goto __lookahead_succeed_;
    } else { 
      if ((scanner.la()->id == AlanToken::FLOAT)) {
        if (!laConsumeToken(AlanToken::FLOAT)) goto __lookahead_fail_;
        if (_la == 0) goto __lookahead_succeed_;
      } else { 
        if (!laConsumeToken(AlanToken::STRING)) goto __lookahead_fail_;
        if (_la == 0) goto __lookahead_succeed_;
      }
    }
  }
  
  __lookahead_succeed_:
    return true;
    
  __lookahead_fail_:
    return false;
}


bool cppcc::AlanParser::__la_declVarList_ () throw (ScanException)
{
  if (!__la_declVar_()) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  while ((scanner.la()->id == AlanToken::COMMA)) {
    if (!laConsumeToken(AlanToken::COMMA)) goto __lookahead_fail_;
    if (_la == 0) goto __lookahead_succeed_;
    if (!__la_declVar_()) goto __lookahead_fail_;
    if (_la == 0) goto __lookahead_succeed_;
  }
  
  __lookahead_succeed_:
    return true;
    
  __lookahead_fail_:
    return false;
}


bool cppcc::AlanParser::__la_declVar_ () throw (ScanException)
{
  if (!laConsumeToken(AlanToken::IDENT)) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  
  __lookahead_succeed_:
    return true;
    
  __lookahead_fail_:
    return false;
}


bool cppcc::AlanParser::__la_Variable_ () throw (ScanException)
{
  if (!laConsumeToken(AlanToken::IDENT)) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  
  __lookahead_succeed_:
    return true;
    
  __lookahead_fail_:
    return false;
}


bool cppcc::AlanParser::__la_instr_move_ () throw (ScanException)
{
  if (!laConsumeToken(AlanToken::MOVE)) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  if (!__la_Expr_()) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  if (!laConsumeToken(AlanToken::COMMA)) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  if (!laConsumeToken(AlanToken::LPAR)) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  if (!__la_Expr_()) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  if (!laConsumeToken(AlanToken::COMMA)) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  if (!__la_Expr_()) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  if (!laConsumeToken(AlanToken::COMMA)) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  if (!__la_Expr_()) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  if ((scanner.la()->id == AlanToken::COMMA)) {
    if (!laConsumeToken(AlanToken::COMMA)) goto __lookahead_fail_;
    if (_la == 0) goto __lookahead_succeed_;
    if (!__la_Expr_()) goto __lookahead_fail_;
    if (_la == 0) goto __lookahead_succeed_;
  } else { 
     /* lambda */
  }
  if (!laConsumeToken(AlanToken::RPAR)) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  while ((scanner.la()->id == AlanToken::LPAR)) {
    if (!laConsumeToken(AlanToken::LPAR)) goto __lookahead_fail_;
    if (_la == 0) goto __lookahead_succeed_;
    if (!__la_Expr_()) goto __lookahead_fail_;
    if (_la == 0) goto __lookahead_succeed_;
    if (!laConsumeToken(AlanToken::COMMA)) goto __lookahead_fail_;
    if (_la == 0) goto __lookahead_succeed_;
    if (!__la_Expr_()) goto __lookahead_fail_;
    if (_la == 0) goto __lookahead_succeed_;
    if (!laConsumeToken(AlanToken::COMMA)) goto __lookahead_fail_;
    if (_la == 0) goto __lookahead_succeed_;
    if (!__la_Expr_()) goto __lookahead_fail_;
    if (_la == 0) goto __lookahead_succeed_;
    if ((scanner.la()->id == AlanToken::COMMA)) {
      if (!laConsumeToken(AlanToken::COMMA)) goto __lookahead_fail_;
      if (_la == 0) goto __lookahead_succeed_;
      if (!__la_Expr_()) goto __lookahead_fail_;
      if (_la == 0) goto __lookahead_succeed_;
    } else { 
       /* lambda */
    }
    if (!laConsumeToken(AlanToken::RPAR)) goto __lookahead_fail_;
    if (_la == 0) goto __lookahead_succeed_;
  }
  
  __lookahead_succeed_:
    return true;
    
  __lookahead_fail_:
    return false;
}


bool cppcc::AlanParser::__la_instr_anim_ () throw (ScanException)
{
  if (!laConsumeToken(AlanToken::ANIM)) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  if (!__la_Expr_()) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  if (!laConsumeToken(AlanToken::COMMA)) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  if (!laConsumeToken(AlanToken::LPAR)) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  if (!__la_Expr_()) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  if (!laConsumeToken(AlanToken::COMMA)) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  if (!__la_Expr_()) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  if (!laConsumeToken(AlanToken::RPAR)) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  while ((scanner.la()->id == AlanToken::LPAR)) {
    if (!laConsumeToken(AlanToken::LPAR)) goto __lookahead_fail_;
    if (_la == 0) goto __lookahead_succeed_;
    if (!__la_Expr_()) goto __lookahead_fail_;
    if (_la == 0) goto __lookahead_succeed_;
    if (!laConsumeToken(AlanToken::COMMA)) goto __lookahead_fail_;
    if (_la == 0) goto __lookahead_succeed_;
    if (!__la_Expr_()) goto __lookahead_fail_;
    if (_la == 0) goto __lookahead_succeed_;
    if (!laConsumeToken(AlanToken::RPAR)) goto __lookahead_fail_;
    if (_la == 0) goto __lookahead_succeed_;
  }
  
  __lookahead_succeed_:
    return true;
    
  __lookahead_fail_:
    return false;
}


bool cppcc::AlanParser::__la_instr_scale_ () throw (ScanException)
{
  if (!laConsumeToken(AlanToken::SCALE)) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  if (!__la_Expr_()) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  if (!laConsumeToken(AlanToken::COMMA)) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  if (!laConsumeToken(AlanToken::LPAR)) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  if (!__la_Expr_()) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  if (!laConsumeToken(AlanToken::COMMA)) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  if (!__la_Expr_()) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  if (!laConsumeToken(AlanToken::COMMA)) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  if (!__la_Expr_()) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  if (!laConsumeToken(AlanToken::RPAR)) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  while ((scanner.la()->id == AlanToken::LPAR)) {
    if (!laConsumeToken(AlanToken::LPAR)) goto __lookahead_fail_;
    if (_la == 0) goto __lookahead_succeed_;
    if (!__la_Expr_()) goto __lookahead_fail_;
    if (_la == 0) goto __lookahead_succeed_;
    if (!laConsumeToken(AlanToken::COMMA)) goto __lookahead_fail_;
    if (_la == 0) goto __lookahead_succeed_;
    if (!__la_Expr_()) goto __lookahead_fail_;
    if (_la == 0) goto __lookahead_succeed_;
    if (!laConsumeToken(AlanToken::COMMA)) goto __lookahead_fail_;
    if (_la == 0) goto __lookahead_succeed_;
    if (!__la_Expr_()) goto __lookahead_fail_;
    if (_la == 0) goto __lookahead_succeed_;
    if (!laConsumeToken(AlanToken::RPAR)) goto __lookahead_fail_;
    if (_la == 0) goto __lookahead_succeed_;
  }
  
  __lookahead_succeed_:
    return true;
    
  __lookahead_fail_:
    return false;
}


bool cppcc::AlanParser::__la_instr_goto_ () throw (ScanException)
{
  if (!laConsumeToken(AlanToken::GOTO)) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  if (!laConsumeToken(AlanToken::IDENT)) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  
  __lookahead_succeed_:
    return true;
    
  __lookahead_fail_:
    return false;
}


bool cppcc::AlanParser::__la_instr_gosub_ () throw (ScanException)
{
  if (!laConsumeToken(AlanToken::GOSUB)) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  if (!laConsumeToken(AlanToken::IDENT)) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  
  __lookahead_succeed_:
    return true;
    
  __lookahead_fail_:
    return false;
}


bool cppcc::AlanParser::__la_instr_return_ () throw (ScanException)
{
  if (!laConsumeToken(AlanToken::RETURN)) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  
  __lookahead_succeed_:
    return true;
    
  __lookahead_fail_:
    return false;
}


bool cppcc::AlanParser::__la_instr_let_ () throw (ScanException)
{
  if (!__la_Variable_()) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  if (!laConsumeToken(AlanToken::ASSIGN)) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  if (!__la_Expr_()) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  
  __lookahead_succeed_:
    return true;
    
  __lookahead_fail_:
    return false;
}


bool cppcc::AlanParser::__la_instr_for_ () throw (ScanException)
{
  if (!laConsumeToken(AlanToken::FOR)) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  if (!__la_Variable_()) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  if (!laConsumeToken(AlanToken::ASSIGN)) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  if (!__la_Expr_()) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  if (!laConsumeToken(AlanToken::TO)) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  if (!__la_Expr_()) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  if ((scanner.la()->id == AlanToken::STEP)) {
    if (!laConsumeToken(AlanToken::STEP)) goto __lookahead_fail_;
    if (_la == 0) goto __lookahead_succeed_;
    if (!__la_Expr_()) goto __lookahead_fail_;
    if (_la == 0) goto __lookahead_succeed_;
  } else { 
     /* lambda */
  }
  
  __lookahead_succeed_:
    return true;
    
  __lookahead_fail_:
    return false;
}


bool cppcc::AlanParser::__la_instr_next_ () throw (ScanException)
{
  if (!laConsumeToken(AlanToken::NEXT)) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  
  __lookahead_succeed_:
    return true;
    
  __lookahead_fail_:
    return false;
}


bool cppcc::AlanParser::__la_instr_while_ () throw (ScanException)
{
  if (!laConsumeToken(AlanToken::WHILE)) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  if (!__la_Expr_()) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  
  __lookahead_succeed_:
    return true;
    
  __lookahead_fail_:
    return false;
}


bool cppcc::AlanParser::__la_instr_wend_ () throw (ScanException)
{
  if (!laConsumeToken(AlanToken::WEND)) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  
  __lookahead_succeed_:
    return true;
    
  __lookahead_fail_:
    return false;
}


bool cppcc::AlanParser::__la_instr_if_ () throw (ScanException)
{
  if (!laConsumeToken(AlanToken::IF)) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  if (!__la_Expr_()) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  
  __lookahead_succeed_:
    return true;
    
  __lookahead_fail_:
    return false;
}


bool cppcc::AlanParser::__la_instr_else_ () throw (ScanException)
{
  if (!laConsumeToken(AlanToken::ELSE)) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  
  __lookahead_succeed_:
    return true;
    
  __lookahead_fail_:
    return false;
}


bool cppcc::AlanParser::__la_instr_eif_ () throw (ScanException)
{
  if (!laConsumeToken(AlanToken::EIF)) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  
  __lookahead_succeed_:
    return true;
    
  __lookahead_fail_:
    return false;
}


bool cppcc::AlanParser::__la_instr_pause_ () throw (ScanException)
{
  if (!laConsumeToken(AlanToken::PAUSE)) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  if (__la_1_(2147483647)) {
    if (!__la_Expr_()) goto __lookahead_fail_;
    if (_la == 0) goto __lookahead_succeed_;
  } else { 
     /* lambda */
  }
  
  __lookahead_succeed_:
    return true;
    
  __lookahead_fail_:
    return false;
}


bool cppcc::AlanParser::__la_1_ (int depth) throw (ScanException)
{
  int _laSave = _la;
  _la = depth;
  scanner.setMarker();
  
  if (!__la_Expr_()) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  goto __lookahead_succeed_;
  
__lookahead_fail_:
  _la = _laSave;
  scanner.rewindToMarker();
  return false;

__lookahead_succeed_:
  _la = _laSave;
  scanner.rewindToMarker();
  return true;
}


bool cppcc::AlanParser::__la_buildinFunc_ () throw (ScanException)
{
  if ((scanner.la()->id == AlanToken::IS)) {
    if (!laConsumeToken(AlanToken::IS)) goto __lookahead_fail_;
    if (_la == 0) goto __lookahead_succeed_;
    if ((scanner.la()->id == AlanToken::MOVING)) {
      if (!laConsumeToken(AlanToken::MOVING)) goto __lookahead_fail_;
      if (_la == 0) goto __lookahead_succeed_;
    } else { 
      if ((scanner.la()->id == AlanToken::ANIMATING)) {
        if (!laConsumeToken(AlanToken::ANIMATING)) goto __lookahead_fail_;
        if (_la == 0) goto __lookahead_succeed_;
      } else { 
        if (!laConsumeToken(AlanToken::SCALING)) goto __lookahead_fail_;
        if (_la == 0) goto __lookahead_succeed_;
      }
    }
  } else { 
    if ((scanner.la()->id == AlanToken::MOUSE)) {
      if (!laConsumeToken(AlanToken::MOUSE)) goto __lookahead_fail_;
      if (_la == 0) goto __lookahead_succeed_;
      if ((scanner.la()->id == AlanToken::IDENT)) {
        if (!__la_Variable_()) goto __lookahead_fail_;
        if (_la == 0) goto __lookahead_succeed_;
      } else { 
        if (!laConsumeToken(AlanToken::KEY)) goto __lookahead_fail_;
        if (_la == 0) goto __lookahead_succeed_;
        if (!laConsumeToken(AlanToken::LPAR)) goto __lookahead_fail_;
        if (_la == 0) goto __lookahead_succeed_;
        if (!__la_Expr_()) goto __lookahead_fail_;
        if (_la == 0) goto __lookahead_succeed_;
        if (!laConsumeToken(AlanToken::RPAR)) goto __lookahead_fail_;
        if (_la == 0) goto __lookahead_succeed_;
      }
    } else { 
      if ((scanner.la()->id == AlanToken::STRLEN)) {
        if (!laConsumeToken(AlanToken::STRLEN)) goto __lookahead_fail_;
        if (_la == 0) goto __lookahead_succeed_;
        if (!laConsumeToken(AlanToken::LPAR)) goto __lookahead_fail_;
        if (_la == 0) goto __lookahead_succeed_;
        if (!__la_Expr_()) goto __lookahead_fail_;
        if (_la == 0) goto __lookahead_succeed_;
        if (!laConsumeToken(AlanToken::RPAR)) goto __lookahead_fail_;
        if (_la == 0) goto __lookahead_succeed_;
      } else { 
        if ((scanner.la()->id == AlanToken::SUBSTR)) {
          if (!laConsumeToken(AlanToken::SUBSTR)) goto __lookahead_fail_;
          if (_la == 0) goto __lookahead_succeed_;
          if (!laConsumeToken(AlanToken::LPAR)) goto __lookahead_fail_;
          if (_la == 0) goto __lookahead_succeed_;
          if (!__la_Expr_()) goto __lookahead_fail_;
          if (_la == 0) goto __lookahead_succeed_;
          if (!laConsumeToken(AlanToken::COMMA)) goto __lookahead_fail_;
          if (_la == 0) goto __lookahead_succeed_;
          if (!__la_Expr_()) goto __lookahead_fail_;
          if (_la == 0) goto __lookahead_succeed_;
          if (!laConsumeToken(AlanToken::COMMA)) goto __lookahead_fail_;
          if (_la == 0) goto __lookahead_succeed_;
          if (!__la_Expr_()) goto __lookahead_fail_;
          if (_la == 0) goto __lookahead_succeed_;
          if (!laConsumeToken(AlanToken::RPAR)) goto __lookahead_fail_;
          if (_la == 0) goto __lookahead_succeed_;
        } else { 
          if ((scanner.la()->id == AlanToken::INSTR)) {
            if (!laConsumeToken(AlanToken::INSTR)) goto __lookahead_fail_;
            if (_la == 0) goto __lookahead_succeed_;
            if (!laConsumeToken(AlanToken::LPAR)) goto __lookahead_fail_;
            if (_la == 0) goto __lookahead_succeed_;
            if (!__la_Expr_()) goto __lookahead_fail_;
            if (_la == 0) goto __lookahead_succeed_;
            if (!laConsumeToken(AlanToken::COMMA)) goto __lookahead_fail_;
            if (_la == 0) goto __lookahead_succeed_;
            if (!__la_Expr_()) goto __lookahead_fail_;
            if (_la == 0) goto __lookahead_succeed_;
            if (!laConsumeToken(AlanToken::COMMA)) goto __lookahead_fail_;
            if (_la == 0) goto __lookahead_succeed_;
            if (!__la_Expr_()) goto __lookahead_fail_;
            if (_la == 0) goto __lookahead_succeed_;
            if (!laConsumeToken(AlanToken::RPAR)) goto __lookahead_fail_;
            if (_la == 0) goto __lookahead_succeed_;
          } else { 
            if ((scanner.la()->id == AlanToken::RAND)) {
              if (!laConsumeToken(AlanToken::RAND)) goto __lookahead_fail_;
              if (_la == 0) goto __lookahead_succeed_;
              if (!laConsumeToken(AlanToken::LPAR)) goto __lookahead_fail_;
              if (_la == 0) goto __lookahead_succeed_;
              if (!__la_Expr_()) goto __lookahead_fail_;
              if (_la == 0) goto __lookahead_succeed_;
              if (!laConsumeToken(AlanToken::COMMA)) goto __lookahead_fail_;
              if (_la == 0) goto __lookahead_succeed_;
              if (!__la_Expr_()) goto __lookahead_fail_;
              if (_la == 0) goto __lookahead_succeed_;
              if (!laConsumeToken(AlanToken::RPAR)) goto __lookahead_fail_;
              if (_la == 0) goto __lookahead_succeed_;
            } else { 
              if ((scanner.la()->id == AlanToken::RANDF)) {
                if (!laConsumeToken(AlanToken::RANDF)) goto __lookahead_fail_;
                if (_la == 0) goto __lookahead_succeed_;
                if (!laConsumeToken(AlanToken::LPAR)) goto __lookahead_fail_;
                if (_la == 0) goto __lookahead_succeed_;
                if (!__la_Expr_()) goto __lookahead_fail_;
                if (_la == 0) goto __lookahead_succeed_;
                if (!laConsumeToken(AlanToken::COMMA)) goto __lookahead_fail_;
                if (_la == 0) goto __lookahead_succeed_;
                if (!__la_Expr_()) goto __lookahead_fail_;
                if (_la == 0) goto __lookahead_succeed_;
                if (!laConsumeToken(AlanToken::RPAR)) goto __lookahead_fail_;
                if (_la == 0) goto __lookahead_succeed_;
              } else { 
                if ((scanner.la()->id == AlanToken::SIN)) {
                  if (!laConsumeToken(AlanToken::SIN)) goto __lookahead_fail_;
                  if (_la == 0) goto __lookahead_succeed_;
                  if (!laConsumeToken(AlanToken::LPAR)) goto __lookahead_fail_;
                  if (_la == 0) goto __lookahead_succeed_;
                  if (!__la_Expr_()) goto __lookahead_fail_;
                  if (_la == 0) goto __lookahead_succeed_;
                  if (!laConsumeToken(AlanToken::RPAR)) goto __lookahead_fail_;
                  if (_la == 0) goto __lookahead_succeed_;
                } else { 
                  if ((scanner.la()->id == AlanToken::COS)) {
                    if (!laConsumeToken(AlanToken::COS)) goto __lookahead_fail_;
                    if (_la == 0) goto __lookahead_succeed_;
                    if (!laConsumeToken(AlanToken::LPAR)) goto __lookahead_fail_;
                    if (_la == 0) goto __lookahead_succeed_;
                    if (!__la_Expr_()) goto __lookahead_fail_;
                    if (_la == 0) goto __lookahead_succeed_;
                    if (!laConsumeToken(AlanToken::RPAR)) goto __lookahead_fail_;
                    if (_la == 0) goto __lookahead_succeed_;
                  } else { 
                    if ((scanner.la()->id == AlanToken::TAN)) {
                      if (!laConsumeToken(AlanToken::TAN)) goto __lookahead_fail_;
                      if (_la == 0) goto __lookahead_succeed_;
                      if (!laConsumeToken(AlanToken::LPAR)) goto __lookahead_fail_;
                      if (_la == 0) goto __lookahead_succeed_;
                      if (!__la_Expr_()) goto __lookahead_fail_;
                      if (_la == 0) goto __lookahead_succeed_;
                      if (!laConsumeToken(AlanToken::RPAR)) goto __lookahead_fail_;
                      if (_la == 0) goto __lookahead_succeed_;
                    } else { 
                      if ((scanner.la()->id == AlanToken::EXP)) {
                        if (!laConsumeToken(AlanToken::EXP)) goto __lookahead_fail_;
                        if (_la == 0) goto __lookahead_succeed_;
                        if (!laConsumeToken(AlanToken::LPAR)) goto __lookahead_fail_;
                        if (_la == 0) goto __lookahead_succeed_;
                        if (!__la_Expr_()) goto __lookahead_fail_;
                        if (_la == 0) goto __lookahead_succeed_;
                        if (!laConsumeToken(AlanToken::RPAR)) goto __lookahead_fail_;
                        if (_la == 0) goto __lookahead_succeed_;
                      } else { 
                        if ((scanner.la()->id == AlanToken::LOG)) {
                          if (!laConsumeToken(AlanToken::LOG)) goto __lookahead_fail_;
                          if (_la == 0) goto __lookahead_succeed_;
                          if (!laConsumeToken(AlanToken::LPAR)) goto __lookahead_fail_;
                          if (_la == 0) goto __lookahead_succeed_;
                          if (!__la_Expr_()) goto __lookahead_fail_;
                          if (_la == 0) goto __lookahead_succeed_;
                          if (!laConsumeToken(AlanToken::RPAR)) goto __lookahead_fail_;
                          if (_la == 0) goto __lookahead_succeed_;
                        } else { 
                          if ((scanner.la()->id == AlanToken::POW)) {
                            if (!laConsumeToken(AlanToken::POW)) goto __lookahead_fail_;
                            if (_la == 0) goto __lookahead_succeed_;
                            if (!laConsumeToken(AlanToken::LPAR)) goto __lookahead_fail_;
                            if (_la == 0) goto __lookahead_succeed_;
                            if (!__la_Expr_()) goto __lookahead_fail_;
                            if (_la == 0) goto __lookahead_succeed_;
                            if (!laConsumeToken(AlanToken::COMMA)) goto __lookahead_fail_;
                            if (_la == 0) goto __lookahead_succeed_;
                            if (!__la_Expr_()) goto __lookahead_fail_;
                            if (_la == 0) goto __lookahead_succeed_;
                            if (!laConsumeToken(AlanToken::RPAR)) goto __lookahead_fail_;
                            if (_la == 0) goto __lookahead_succeed_;
                          } else { 
                            if ((scanner.la()->id == AlanToken::SQRT)) {
                              if (!laConsumeToken(AlanToken::SQRT)) goto __lookahead_fail_;
                              if (_la == 0) goto __lookahead_succeed_;
                              if (!laConsumeToken(AlanToken::LPAR)) goto __lookahead_fail_;
                              if (_la == 0) goto __lookahead_succeed_;
                              if (!__la_Expr_()) goto __lookahead_fail_;
                              if (_la == 0) goto __lookahead_succeed_;
                              if (!laConsumeToken(AlanToken::RPAR)) goto __lookahead_fail_;
                              if (_la == 0) goto __lookahead_succeed_;
                            } else { 
                              if ((scanner.la()->id == AlanToken::ABS)) {
                                if (!laConsumeToken(AlanToken::ABS)) goto __lookahead_fail_;
                                if (_la == 0) goto __lookahead_succeed_;
                                if (!laConsumeToken(AlanToken::LPAR)) goto __lookahead_fail_;
                                if (_la == 0) goto __lookahead_succeed_;
                                if (!__la_Expr_()) goto __lookahead_fail_;
                                if (_la == 0) goto __lookahead_succeed_;
                                if (!laConsumeToken(AlanToken::RPAR)) goto __lookahead_fail_;
                                if (_la == 0) goto __lookahead_succeed_;
                              } else { 
                                if ((scanner.la()->id == AlanToken::SGN)) {
                                  if (!laConsumeToken(AlanToken::SGN)) goto __lookahead_fail_;
                                  if (_la == 0) goto __lookahead_succeed_;
                                  if (!laConsumeToken(AlanToken::LPAR)) goto __lookahead_fail_;
                                  if (_la == 0) goto __lookahead_succeed_;
                                  if (!__la_Expr_()) goto __lookahead_fail_;
                                  if (_la == 0) goto __lookahead_succeed_;
                                  if (!laConsumeToken(AlanToken::RPAR)) goto __lookahead_fail_;
                                  if (_la == 0) goto __lookahead_succeed_;
                                } else { 
                                  if ((scanner.la()->id == AlanToken::FLOOR)) {
                                    if (!laConsumeToken(AlanToken::FLOOR)) goto __lookahead_fail_;
                                    if (_la == 0) goto __lookahead_succeed_;
                                    if (!laConsumeToken(AlanToken::LPAR)) goto __lookahead_fail_;
                                    if (_la == 0) goto __lookahead_succeed_;
                                    if (!__la_Expr_()) goto __lookahead_fail_;
                                    if (_la == 0) goto __lookahead_succeed_;
                                    if (!laConsumeToken(AlanToken::RPAR)) goto __lookahead_fail_;
                                    if (_la == 0) goto __lookahead_succeed_;
                                  } else { 
                                    if ((scanner.la()->id == AlanToken::CEIL)) {
                                      if (!laConsumeToken(AlanToken::CEIL)) goto __lookahead_fail_;
                                      if (_la == 0) goto __lookahead_succeed_;
                                      if (!laConsumeToken(AlanToken::LPAR)) goto __lookahead_fail_;
                                      if (_la == 0) goto __lookahead_succeed_;
                                      if (!__la_Expr_()) goto __lookahead_fail_;
                                      if (_la == 0) goto __lookahead_succeed_;
                                      if (!laConsumeToken(AlanToken::RPAR)) goto __lookahead_fail_;
                                      if (_la == 0) goto __lookahead_succeed_;
                                    } else { 
                                      if ((scanner.la()->id == AlanToken::MIN)) {
                                        if (!laConsumeToken(AlanToken::MIN)) goto __lookahead_fail_;
                                        if (_la == 0) goto __lookahead_succeed_;
                                        if (!laConsumeToken(AlanToken::LPAR)) goto __lookahead_fail_;
                                        if (_la == 0) goto __lookahead_succeed_;
                                        if (!__la_Expr_()) goto __lookahead_fail_;
                                        if (_la == 0) goto __lookahead_succeed_;
                                        if (!laConsumeToken(AlanToken::COMMA)) goto __lookahead_fail_;
                                        if (_la == 0) goto __lookahead_succeed_;
                                        if (!__la_Expr_()) goto __lookahead_fail_;
                                        if (_la == 0) goto __lookahead_succeed_;
                                        if (!laConsumeToken(AlanToken::RPAR)) goto __lookahead_fail_;
                                        if (_la == 0) goto __lookahead_succeed_;
                                      } else { 
                                        if (!laConsumeToken(AlanToken::MAX)) goto __lookahead_fail_;
                                        if (_la == 0) goto __lookahead_succeed_;
                                        if (!laConsumeToken(AlanToken::LPAR)) goto __lookahead_fail_;
                                        if (_la == 0) goto __lookahead_succeed_;
                                        if (!__la_Expr_()) goto __lookahead_fail_;
                                        if (_la == 0) goto __lookahead_succeed_;
                                        if (!laConsumeToken(AlanToken::COMMA)) goto __lookahead_fail_;
                                        if (_la == 0) goto __lookahead_succeed_;
                                        if (!__la_Expr_()) goto __lookahead_fail_;
                                        if (_la == 0) goto __lookahead_succeed_;
                                        if (!laConsumeToken(AlanToken::RPAR)) goto __lookahead_fail_;
                                        if (_la == 0) goto __lookahead_succeed_;
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
  __lookahead_succeed_:
    return true;
    
  __lookahead_fail_:
    return false;
}


bool cppcc::AlanParser::__la_primaryExpr_ () throw (ScanException)
{
  if ((scanner.la()->id == AlanToken::IDENT)) {
    if (!__la_Variable_()) goto __lookahead_fail_;
    if (_la == 0) goto __lookahead_succeed_;
  } else { 
    if ((scanner.la()->id == AlanToken::IS) || (scanner.la()->id == AlanToken::MOUSE) || (scanner.la()->id == AlanToken::STRLEN) || (scanner.la()->id == AlanToken::SUBSTR) || (scanner.la()->id == AlanToken::INSTR) || (scanner.la()->id == AlanToken::RAND) || (scanner.la()->id == AlanToken::RANDF) || (scanner.la()->id == AlanToken::SIN) || (scanner.la()->id == AlanToken::COS) || (scanner.la()->id == AlanToken::TAN) || (scanner.la()->id == AlanToken::EXP) || (scanner.la()->id == AlanToken::LOG) || (scanner.la()->id == AlanToken::POW) || (scanner.la()->id == AlanToken::SQRT) || (scanner.la()->id == AlanToken::ABS) || (scanner.la()->id == AlanToken::SGN) || (scanner.la()->id == AlanToken::FLOOR) || (scanner.la()->id == AlanToken::CEIL) || (scanner.la()->id == AlanToken::MIN) || (scanner.la()->id == AlanToken::MAX)) {
      if (!__la_buildinFunc_()) goto __lookahead_fail_;
      if (_la == 0) goto __lookahead_succeed_;
    } else { 
      if ((scanner.la()->id == AlanToken::TRUE) || (scanner.la()->id == AlanToken::FALSE) || (scanner.la()->id == AlanToken::DEC_CONSTANT) || (scanner.la()->id == AlanToken::FLOAT_CONSTANT) || (scanner.la()->id == AlanToken::STRING_LITERAL)) {
        if (!__la_Constant_()) goto __lookahead_fail_;
        if (_la == 0) goto __lookahead_succeed_;
      } else { 
        if (!laConsumeToken(AlanToken::LPAR)) goto __lookahead_fail_;
        if (_la == 0) goto __lookahead_succeed_;
        if (!__la_Expr_()) goto __lookahead_fail_;
        if (_la == 0) goto __lookahead_succeed_;
        if (!laConsumeToken(AlanToken::RPAR)) goto __lookahead_fail_;
        if (_la == 0) goto __lookahead_succeed_;
      }
    }
  }
  
  __lookahead_succeed_:
    return true;
    
  __lookahead_fail_:
    return false;
}


bool cppcc::AlanParser::__la_unaryExpr_ () throw (ScanException)
{
  if ((scanner.la()->id == AlanToken::LPAR) || (scanner.la()->id == AlanToken::TRUE) || (scanner.la()->id == AlanToken::FALSE) || (scanner.la()->id == AlanToken::IS) || (scanner.la()->id == AlanToken::MOUSE) || (scanner.la()->id == AlanToken::STRLEN) || (scanner.la()->id == AlanToken::SUBSTR) || (scanner.la()->id == AlanToken::INSTR) || (scanner.la()->id == AlanToken::RAND) || (scanner.la()->id == AlanToken::RANDF) || (scanner.la()->id == AlanToken::SIN) || (scanner.la()->id == AlanToken::COS) || (scanner.la()->id == AlanToken::TAN) || (scanner.la()->id == AlanToken::EXP) || (scanner.la()->id == AlanToken::LOG) || (scanner.la()->id == AlanToken::POW) || (scanner.la()->id == AlanToken::SQRT) || (scanner.la()->id == AlanToken::ABS) || (scanner.la()->id == AlanToken::SGN) || (scanner.la()->id == AlanToken::FLOOR) || (scanner.la()->id == AlanToken::CEIL) || (scanner.la()->id == AlanToken::MIN) || (scanner.la()->id == AlanToken::MAX) || (scanner.la()->id == AlanToken::DEC_CONSTANT) || (scanner.la()->id == AlanToken::FLOAT_CONSTANT) || (scanner.la()->id == AlanToken::STRING_LITERAL) || (scanner.la()->id == AlanToken::IDENT)) {
    if (!__la_primaryExpr_()) goto __lookahead_fail_;
    if (_la == 0) goto __lookahead_succeed_;
  } else { 
    if ((scanner.la()->id == AlanToken::MINUS)) {
      if (!laConsumeToken(AlanToken::MINUS)) goto __lookahead_fail_;
      if (_la == 0) goto __lookahead_succeed_;
      if (!__la_unaryExpr_()) goto __lookahead_fail_;
      if (_la == 0) goto __lookahead_succeed_;
    } else { 
      if (!laConsumeToken(AlanToken::PLUS)) goto __lookahead_fail_;
      if (_la == 0) goto __lookahead_succeed_;
      if (!__la_unaryExpr_()) goto __lookahead_fail_;
      if (_la == 0) goto __lookahead_succeed_;
    }
  }
  
  __lookahead_succeed_:
    return true;
    
  __lookahead_fail_:
    return false;
}


bool cppcc::AlanParser::__la_castExpr_ () throw (ScanException)
{
  if ((scanner.la()->id == AlanToken::LPAR) || (scanner.la()->id == AlanToken::PLUS) || (scanner.la()->id == AlanToken::MINUS) || (scanner.la()->id == AlanToken::TRUE) || (scanner.la()->id == AlanToken::FALSE) || (scanner.la()->id == AlanToken::IS) || (scanner.la()->id == AlanToken::MOUSE) || (scanner.la()->id == AlanToken::STRLEN) || (scanner.la()->id == AlanToken::SUBSTR) || (scanner.la()->id == AlanToken::INSTR) || (scanner.la()->id == AlanToken::RAND) || (scanner.la()->id == AlanToken::RANDF) || (scanner.la()->id == AlanToken::SIN) || (scanner.la()->id == AlanToken::COS) || (scanner.la()->id == AlanToken::TAN) || (scanner.la()->id == AlanToken::EXP) || (scanner.la()->id == AlanToken::LOG) || (scanner.la()->id == AlanToken::POW) || (scanner.la()->id == AlanToken::SQRT) || (scanner.la()->id == AlanToken::ABS) || (scanner.la()->id == AlanToken::SGN) || (scanner.la()->id == AlanToken::FLOOR) || (scanner.la()->id == AlanToken::CEIL) || (scanner.la()->id == AlanToken::MIN) || (scanner.la()->id == AlanToken::MAX) || (scanner.la()->id == AlanToken::DEC_CONSTANT) || (scanner.la()->id == AlanToken::FLOAT_CONSTANT) || (scanner.la()->id == AlanToken::STRING_LITERAL) || (scanner.la()->id == AlanToken::IDENT)) {
    if (!__la_unaryExpr_()) goto __lookahead_fail_;
    if (_la == 0) goto __lookahead_succeed_;
  } else { 
    if ((scanner.la()->id == AlanToken::BOOL)) {
      if (!laConsumeToken(AlanToken::BOOL)) goto __lookahead_fail_;
      if (_la == 0) goto __lookahead_succeed_;
      if (!laConsumeToken(AlanToken::LPAR)) goto __lookahead_fail_;
      if (_la == 0) goto __lookahead_succeed_;
      if (!__la_castExpr_()) goto __lookahead_fail_;
      if (_la == 0) goto __lookahead_succeed_;
      if (!laConsumeToken(AlanToken::RPAR)) goto __lookahead_fail_;
      if (_la == 0) goto __lookahead_succeed_;
    } else { 
      if ((scanner.la()->id == AlanToken::INT)) {
        if (!laConsumeToken(AlanToken::INT)) goto __lookahead_fail_;
        if (_la == 0) goto __lookahead_succeed_;
        if (!laConsumeToken(AlanToken::LPAR)) goto __lookahead_fail_;
        if (_la == 0) goto __lookahead_succeed_;
        if (!__la_castExpr_()) goto __lookahead_fail_;
        if (_la == 0) goto __lookahead_succeed_;
        if (!laConsumeToken(AlanToken::RPAR)) goto __lookahead_fail_;
        if (_la == 0) goto __lookahead_succeed_;
      } else { 
        if ((scanner.la()->id == AlanToken::FLOAT)) {
          if (!laConsumeToken(AlanToken::FLOAT)) goto __lookahead_fail_;
          if (_la == 0) goto __lookahead_succeed_;
          if (!laConsumeToken(AlanToken::LPAR)) goto __lookahead_fail_;
          if (_la == 0) goto __lookahead_succeed_;
          if (!__la_castExpr_()) goto __lookahead_fail_;
          if (_la == 0) goto __lookahead_succeed_;
          if (!laConsumeToken(AlanToken::RPAR)) goto __lookahead_fail_;
          if (_la == 0) goto __lookahead_succeed_;
        } else { 
          if (!laConsumeToken(AlanToken::STRING)) goto __lookahead_fail_;
          if (_la == 0) goto __lookahead_succeed_;
          if (!laConsumeToken(AlanToken::LPAR)) goto __lookahead_fail_;
          if (_la == 0) goto __lookahead_succeed_;
          if (!__la_castExpr_()) goto __lookahead_fail_;
          if (_la == 0) goto __lookahead_succeed_;
          if (!laConsumeToken(AlanToken::RPAR)) goto __lookahead_fail_;
          if (_la == 0) goto __lookahead_succeed_;
        }
      }
    }
  }
  
  __lookahead_succeed_:
    return true;
    
  __lookahead_fail_:
    return false;
}


bool cppcc::AlanParser::__la_multiplicativeExpr_ () throw (ScanException)
{
  if (!__la_castExpr_()) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  while ((scanner.la()->id == AlanToken::MUL) || (scanner.la()->id == AlanToken::DIV) || (scanner.la()->id == AlanToken::MOD)) {
    if ((scanner.la()->id == AlanToken::MUL)) {
      if (!laConsumeToken(AlanToken::MUL)) goto __lookahead_fail_;
      if (_la == 0) goto __lookahead_succeed_;
      if (!__la_castExpr_()) goto __lookahead_fail_;
      if (_la == 0) goto __lookahead_succeed_;
    } else { 
      if ((scanner.la()->id == AlanToken::DIV)) {
        if (!laConsumeToken(AlanToken::DIV)) goto __lookahead_fail_;
        if (_la == 0) goto __lookahead_succeed_;
        if (!__la_castExpr_()) goto __lookahead_fail_;
        if (_la == 0) goto __lookahead_succeed_;
      } else { 
        if (!laConsumeToken(AlanToken::MOD)) goto __lookahead_fail_;
        if (_la == 0) goto __lookahead_succeed_;
        if (!__la_castExpr_()) goto __lookahead_fail_;
        if (_la == 0) goto __lookahead_succeed_;
      }
    }
  }
  
  __lookahead_succeed_:
    return true;
    
  __lookahead_fail_:
    return false;
}


bool cppcc::AlanParser::__la_additiveExpr_ () throw (ScanException)
{
  if (!__la_multiplicativeExpr_()) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  while ((scanner.la()->id == AlanToken::PLUS) || (scanner.la()->id == AlanToken::MINUS)) {
    if ((scanner.la()->id == AlanToken::PLUS)) {
      if (!laConsumeToken(AlanToken::PLUS)) goto __lookahead_fail_;
      if (_la == 0) goto __lookahead_succeed_;
      if (!__la_multiplicativeExpr_()) goto __lookahead_fail_;
      if (_la == 0) goto __lookahead_succeed_;
    } else { 
      if (!laConsumeToken(AlanToken::MINUS)) goto __lookahead_fail_;
      if (_la == 0) goto __lookahead_succeed_;
      if (!__la_multiplicativeExpr_()) goto __lookahead_fail_;
      if (_la == 0) goto __lookahead_succeed_;
    }
  }
  
  __lookahead_succeed_:
    return true;
    
  __lookahead_fail_:
    return false;
}


bool cppcc::AlanParser::__la_relExpr_ () throw (ScanException)
{
  if (!__la_additiveExpr_()) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  while ((scanner.la()->id == AlanToken::ASSIGN) || (scanner.la()->id == AlanToken::LT) || (scanner.la()->id == AlanToken::GT) || (scanner.la()->id == AlanToken::LE) || (scanner.la()->id == AlanToken::GE) || (scanner.la()->id == AlanToken::NE)) {
    if (!__la_RelOp2_()) goto __lookahead_fail_;
    if (_la == 0) goto __lookahead_succeed_;
    if (!__la_additiveExpr_()) goto __lookahead_fail_;
    if (_la == 0) goto __lookahead_succeed_;
  }
  
  __lookahead_succeed_:
    return true;
    
  __lookahead_fail_:
    return false;
}


bool cppcc::AlanParser::__la_RelOp2_ () throw (ScanException)
{
  if ((scanner.la()->id == AlanToken::ASSIGN)) {
    if (!laConsumeToken(AlanToken::ASSIGN)) goto __lookahead_fail_;
    if (_la == 0) goto __lookahead_succeed_;
  } else { 
    if ((scanner.la()->id == AlanToken::NE)) {
      if (!laConsumeToken(AlanToken::NE)) goto __lookahead_fail_;
      if (_la == 0) goto __lookahead_succeed_;
    } else { 
      if ((scanner.la()->id == AlanToken::LT)) {
        if (!laConsumeToken(AlanToken::LT)) goto __lookahead_fail_;
        if (_la == 0) goto __lookahead_succeed_;
      } else { 
        if ((scanner.la()->id == AlanToken::GT)) {
          if (!laConsumeToken(AlanToken::GT)) goto __lookahead_fail_;
          if (_la == 0) goto __lookahead_succeed_;
        } else { 
          if ((scanner.la()->id == AlanToken::LE)) {
            if (!laConsumeToken(AlanToken::LE)) goto __lookahead_fail_;
            if (_la == 0) goto __lookahead_succeed_;
          } else { 
            if (!laConsumeToken(AlanToken::GE)) goto __lookahead_fail_;
            if (_la == 0) goto __lookahead_succeed_;
          }
        }
      }
    }
  }
  
  __lookahead_succeed_:
    return true;
    
  __lookahead_fail_:
    return false;
}


bool cppcc::AlanParser::__la_unaryBoolExpr_ () throw (ScanException)
{
  if ((scanner.la()->id == AlanToken::LPAR) || (scanner.la()->id == AlanToken::PLUS) || (scanner.la()->id == AlanToken::MINUS) || (scanner.la()->id == AlanToken::TRUE) || (scanner.la()->id == AlanToken::FALSE) || (scanner.la()->id == AlanToken::BOOL) || (scanner.la()->id == AlanToken::INT) || (scanner.la()->id == AlanToken::FLOAT) || (scanner.la()->id == AlanToken::STRING) || (scanner.la()->id == AlanToken::IS) || (scanner.la()->id == AlanToken::MOUSE) || (scanner.la()->id == AlanToken::STRLEN) || (scanner.la()->id == AlanToken::SUBSTR) || (scanner.la()->id == AlanToken::INSTR) || (scanner.la()->id == AlanToken::RAND) || (scanner.la()->id == AlanToken::RANDF) || (scanner.la()->id == AlanToken::SIN) || (scanner.la()->id == AlanToken::COS) || (scanner.la()->id == AlanToken::TAN) || (scanner.la()->id == AlanToken::EXP) || (scanner.la()->id == AlanToken::LOG) || (scanner.la()->id == AlanToken::POW) || (scanner.la()->id == AlanToken::SQRT) || (scanner.la()->id == AlanToken::ABS) || (scanner.la()->id == AlanToken::SGN) || (scanner.la()->id == AlanToken::FLOOR) || (scanner.la()->id == AlanToken::CEIL) || (scanner.la()->id == AlanToken::MIN) || (scanner.la()->id == AlanToken::MAX) || (scanner.la()->id == AlanToken::DEC_CONSTANT) || (scanner.la()->id == AlanToken::FLOAT_CONSTANT) || (scanner.la()->id == AlanToken::STRING_LITERAL) || (scanner.la()->id == AlanToken::IDENT)) {
    if (!__la_relExpr_()) goto __lookahead_fail_;
    if (_la == 0) goto __lookahead_succeed_;
  } else { 
    if (!laConsumeToken(AlanToken::NOT)) goto __lookahead_fail_;
    if (_la == 0) goto __lookahead_succeed_;
    if (!__la_unaryBoolExpr_()) goto __lookahead_fail_;
    if (_la == 0) goto __lookahead_succeed_;
  }
  
  __lookahead_succeed_:
    return true;
    
  __lookahead_fail_:
    return false;
}


bool cppcc::AlanParser::__la_mulBoolExpr_ () throw (ScanException)
{
  if (!__la_unaryBoolExpr_()) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  while ((scanner.la()->id == AlanToken::AND)) {
    if (!laConsumeToken(AlanToken::AND)) goto __lookahead_fail_;
    if (_la == 0) goto __lookahead_succeed_;
    if (!__la_unaryBoolExpr_()) goto __lookahead_fail_;
    if (_la == 0) goto __lookahead_succeed_;
  }
  
  __lookahead_succeed_:
    return true;
    
  __lookahead_fail_:
    return false;
}


bool cppcc::AlanParser::__la_addBoolExpr_ () throw (ScanException)
{
  if (!__la_mulBoolExpr_()) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  while ((scanner.la()->id == AlanToken::OR)) {
    if (!laConsumeToken(AlanToken::OR)) goto __lookahead_fail_;
    if (_la == 0) goto __lookahead_succeed_;
    if (!__la_mulBoolExpr_()) goto __lookahead_fail_;
    if (_la == 0) goto __lookahead_succeed_;
  }
  
  __lookahead_succeed_:
    return true;
    
  __lookahead_fail_:
    return false;
}


bool cppcc::AlanParser::__la_Expr_ () throw (ScanException)
{
  if (!__la_addBoolExpr_()) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  
  __lookahead_succeed_:
    return true;
    
  __lookahead_fail_:
    return false;
}


bool cppcc::AlanParser::__la_FloatConstant_ () throw (ScanException)
{
  if (!laConsumeToken(AlanToken::FLOAT_CONSTANT)) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  
  __lookahead_succeed_:
    return true;
    
  __lookahead_fail_:
    return false;
}


bool cppcc::AlanParser::__la_DecConstant_ () throw (ScanException)
{
  if (!laConsumeToken(AlanToken::DEC_CONSTANT)) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  
  __lookahead_succeed_:
    return true;
    
  __lookahead_fail_:
    return false;
}


bool cppcc::AlanParser::__la_BoolConstant_ () throw (ScanException)
{
  if ((scanner.la()->id == AlanToken::TRUE)) {
    if (!laConsumeToken(AlanToken::TRUE)) goto __lookahead_fail_;
    if (_la == 0) goto __lookahead_succeed_;
  } else { 
    if (!laConsumeToken(AlanToken::FALSE)) goto __lookahead_fail_;
    if (_la == 0) goto __lookahead_succeed_;
  }
  
  __lookahead_succeed_:
    return true;
    
  __lookahead_fail_:
    return false;
}


bool cppcc::AlanParser::__la_StringConstant_ () throw (ScanException)
{
  if (!laConsumeToken(AlanToken::STRING_LITERAL)) goto __lookahead_fail_;
  if (_la == 0) goto __lookahead_succeed_;
  
  __lookahead_succeed_:
    return true;
    
  __lookahead_fail_:
    return false;
}


bool cppcc::AlanParser::__la_Constant_ () throw (ScanException)
{
  if ((scanner.la()->id == AlanToken::FLOAT_CONSTANT)) {
    if (!__la_FloatConstant_()) goto __lookahead_fail_;
    if (_la == 0) goto __lookahead_succeed_;
  } else { 
    if ((scanner.la()->id == AlanToken::DEC_CONSTANT)) {
      if (!__la_DecConstant_()) goto __lookahead_fail_;
      if (_la == 0) goto __lookahead_succeed_;
    } else { 
      if ((scanner.la()->id == AlanToken::TRUE) || (scanner.la()->id == AlanToken::FALSE)) {
        if (!__la_BoolConstant_()) goto __lookahead_fail_;
        if (_la == 0) goto __lookahead_succeed_;
      } else { 
        if (!__la_StringConstant_()) goto __lookahead_fail_;
        if (_la == 0) goto __lookahead_succeed_;
      }
    }
  }
  
  __lookahead_succeed_:
    return true;
    
  __lookahead_fail_:
    return false;
}





/* End of file. */
